# Copyright (c) 2016 Shotgun Software Inc.
# 
# CONFIDENTIAL AND PROPRIETARY
# 
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit 
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your 
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights 
# not expressly granted therein are reserved by Shotgun Software Inc.

import os
import re
import subprocess

from .errors import ShotgunDeployError
from . import constants
from ..shotgun_base import get_sgtk_logger

def get_shotgun_deploy_logger():
    """
    Returns a logger object suitable for the shotgun deploy module.

    This logger should be used for all logged messages inside
    the shotgun_deploy module. Typically, this this imported
    at the top of a python file::

        from . import util
        log = util.get_shotgun_deploy_logger()

    Then, in the running code, calls are made to the log object.

    :returns: python logger
    """
    return get_sgtk_logger("deploy")

log = get_shotgun_deploy_logger()

def is_toolkit_activated_in_shotgun(sg):
    """
    Checks that toolkit has been activated in sg.

    :return: True if true, false otherwise
    """
    log.debug("Checking if Toolkit is enabled in Shotgun...")
    entity_types = sg.schema_entity_read()
    # returns a dict keyed by entity type
    enabled = constants.PIPELINE_CONFIGURATION_ENTITY_TYPE in entity_types
    log.debug("...enabled: %s" % enabled)
    return enabled


def execute_git_command(cmd):
    """
    Wrapper around git execution.
    
    Executes a git command.

    First probes to check if the git executable exists. Next 
    executes the given command. Any output generated by the command
    will not be captured but will get emitted to stdout/stderr.

    Git operates in the context of the current working directory,
    so this method is typically used in the following way::

        cwd = os.getcwd()
        try:
            # do something
            execute_git_command("checkout %s -q" % self._branch)
        finally:
            os.chdir(cwd)

    :raises: Will raise a ShotgunDeployError on failure
    :param cmd: git command to execute (e.g. 'clone foo.git')
    """
    # first probe to check that git exists in our PATH
    try:
        _ = subprocess_check_output("git --version", shell=True)
    except:
        raise ShotgunDeployError(
            "Cannot execute the 'git' command. Please make sure that git is "
            "installed on your system and that the git executable has been added to the PATH."
        )
        
    status = os.system("git %s" % cmd)
    if status != 0:
        raise ShotgunDeployError(
            "Error executing git operation. The git command '%s' "
            "returned error code %s." % (cmd, status)
        )

def create_valid_filename(value):
    """
    Create a sanitized file name given a string.
    Replaces spaces and other characters with underscores

    'my lovely name ' -> 'my_lovely_name'

    :param value: String value to sanitize
    :returns: sanitized string
    """
    # regex to find non-word characters - in ascii land, that is [^A-Za-z0-9_]
    # note that we use a unicode expression, meaning that it will include other
    # "word" characters, not just A-Z.
    exp = re.compile(u"\W", re.UNICODE)

    # strip trailing whitespace
    value = value.strip()

    # assume string is utf-8 encoded. decode, replace
    # and re-encode the returned result
    u_src = value.decode("utf-8")
    return exp.sub("_", u_src).encode("utf-8")


class SubprocessCalledProcessError(Exception):
    """
    Subprocess exception
    """

    def __init__(self, returncode, cmd, output=None):
        self.returncode = returncode
        self.cmd = cmd
        self.output = output

    def __str__(self):
        return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)


def subprocess_check_output(*popenargs, **kwargs):
    """
    Run command with arguments and return its output as a byte string.

    A python 2.6 compatible subprocess.check_output call.
    Subprocess.check_output was added to Python 2.7. For docs, see
    https://docs.python.org/2/library/subprocess.html#subprocess.check_output

    Adopted from from http://stackoverflow.com/questions/2924310

    :returns: The output from the command
    :raises: If the return code was non-zero it raises a SubprocessCalledProcessError.
             The CalledProcessError object will have the return code in the returncode
             attribute and any output in the output attribute.
    """
    if "stdout" in kwargs:
        raise ValueError("stdout argument not allowed, it will be overridden.")
    process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
    output, unused_err = process.communicate()
    retcode = process.poll()
    if retcode:
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = popenargs[0]
        raise SubprocessCalledProcessError(retcode, cmd, output=output)
    return output




<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tank.context &mdash; tk-core v0.22.6 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
    <a href='https://help.autodesk.com/view/SGDEV/ENU/'>
    
        <img style='width: 191px;
                height: 60px;
                margin: 2px;
                border-radius: 0px;
                padding: 0px;'
            src='../../_static/logo@2x.png'/>
    
    </a>
    

          
          
          <a href="../../index.html" class="icon icon-home">
            tk-core
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../initializing.html">Initialization and startup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platform.html">Apps, Engines and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../descriptor.html">Descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authentication.html">Authentication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../environment_variables.html">Environment Variables</a></li>
</ul>


    <a href='genindex.html'>Alphabetic Index</a>

    <div style='margin-top: 50px;
                margin-left: 10px;
                margin-right: 10px;
                padding: 10px;
                color: #b3b3b3;
                font-size: 70%;
                border-radius: 3px;
                background-color: #444;
                line-height: 18px;
                '>
    <style>
        a.custom_post_menu { display: inline;
                             padding: 0px;
                             text-decoration: underline; }
    </style>

    <b>tk-core</b> v0.22.6.<br>
    
        This documentation is part of the Flow Production Tracking.
    
    For more information, please visit
    <a class=custom_post_menu href='https://help.autodesk.com/view/SGDEV/ENU/'>The Flow Production Tracking developer portal.</a>.
    The code associated with this documentation can be found
    <a class=custom_post_menu href='https://github.com/shotgunsoftware/tk-core'>here</a>.

    </div>
    <style>
        p.privacy_links { margin: 4px 0px;}
    </style>
    <p class="privacy_links"><a data-opt-in-preferences href="javascript:;">Privacy settings</a></p>
    <p class="privacy_links"><a data-wat-linkname="manage-ccpa-settings-footer-link" href="javascript:;">Do not sell my personal information</a></p>
    <p class="privacy_links"><a href="https://www.autodesk.com/company/legal-notices-trademarks/privacy-statement">Privacy/Cookies</a></p>



        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">tk-core</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tank.context</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tank.context</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2013 Shotgun Software Inc.</span>
<span class="c1">#</span>
<span class="c1"># CONFIDENTIAL AND PROPRIETARY</span>
<span class="c1">#</span>
<span class="c1"># This work is provided &quot;AS IS&quot; and subject to the Shotgun Pipeline Toolkit</span>
<span class="c1"># Source Code License included in this distribution package. See LICENSE.</span>
<span class="c1"># By accessing, using, copying or modifying this work you indicate your</span>
<span class="c1"># agreement to the Shotgun Pipeline Toolkit Source Code License. All rights</span>
<span class="c1"># not expressly granted therein are reserved by Shotgun Software Inc.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Management of the current context, e.g. the current shotgun entity/step/task.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tank_vendor</span><span class="w"> </span><span class="kn">import</span> <span class="n">yaml</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">authentication</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">login</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">shotgun_entity</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">shotgun</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_sg_entity_name_field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">pickle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.errors</span><span class="w"> </span><span class="kn">import</span> <span class="n">TankError</span><span class="p">,</span> <span class="n">TankContextDeserializationError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.path_cache</span><span class="w"> </span><span class="kn">import</span> <span class="n">PathCache</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.template</span><span class="w"> </span><span class="kn">import</span> <span class="n">TemplatePath</span>


<div class="viewcode-block" id="Context"><a class="viewcode-back" href="../../core.html#sgtk.Context">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">Context</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A context instance is used to collect a set of key fields describing the</span>
<span class="sd">    current Context. We sometimes refer to the context as the current work area.</span>
<span class="sd">    Typically this would be the current shot or asset that someone is working on.</span>

<span class="sd">    The context captures the current point in both shotgun and the file system and context</span>
<span class="sd">    objects are launch a toolkit engine via the :meth:`sgtk.platform.start_engine`</span>
<span class="sd">    method. The context points the engine to a particular</span>
<span class="sd">    point in shotgun and on disk - it could be something as detailed as a task inside a Shot,</span>
<span class="sd">    and something as vague as an empty context.</span>

<span class="sd">    The context is split up into several levels of granularity, reflecting the</span>
<span class="sd">    fundamental hierarchy of Shotgun itself.</span>

<span class="sd">    - The project level defines which shotgun project the context reflects.</span>
<span class="sd">    - The entity level defines which entity the context reflects. For example,</span>
<span class="sd">      this may be a Shot or an Asset. Note that in the case of a Shot, the context</span>
<span class="sd">      does not contain any direct information of which sequence the shot is linked to,</span>
<span class="sd">      however the context can still resolve such relationships implicitly if needed -</span>
<span class="sd">      typically via the :meth:`Context.as_context_fields` method.</span>
<span class="sd">    - The step level defines the current pipeline step. This is often a reflection of a</span>
<span class="sd">      department or a general step in a workflow or pipeline (e.g. Modeling, Rigging).</span>
<span class="sd">    - The task level defines a current Shotgun task.</span>
<span class="sd">    - The user level defines the current user.</span>

<span class="sd">    The data forms a hierarchy, so implicitly, the task belongs to the entity which in turn</span>
<span class="sd">    belongs to the project. The exception to this is the user, which simply reflects the</span>
<span class="sd">    currently operating user.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tk</span><span class="p">,</span>
        <span class="n">project</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">entity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">task</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">user</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_entities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">source_entity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Context objects are not constructed by hand but are fabricated by the</span>
<span class="sd">        methods :meth:`Sgtk.context_from_entity`, :meth:`Sgtk.context_from_entity_dictionary`</span>
<span class="sd">        and :meth:`Sgtk.context_from_path`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span> <span class="o">=</span> <span class="n">tk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__project</span> <span class="o">=</span> <span class="n">project</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__entity</span> <span class="o">=</span> <span class="n">entity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__step</span> <span class="o">=</span> <span class="n">step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__task</span> <span class="o">=</span> <span class="n">task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__user</span> <span class="o">=</span> <span class="n">user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__additional_entities</span> <span class="o">=</span> <span class="n">additional_entities</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__source_entity</span> <span class="o">=</span> <span class="n">source_entity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entity_fields_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># multi line repr</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Project: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__project</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Entity: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__entity</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Step: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__step</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Task: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__task</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  User: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__user</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  PTR URL: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">)</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Additional Entities: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__additional_entities</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Source Entity: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__source_entity</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;&lt;Sgtk Context: </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation for context</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We&#39;re in a &quot;site&quot; context, so we&#39;ll give the site&#39;s url</span>
            <span class="c1"># minus the &quot;https://&quot; if that&#39;s attached.</span>
            <span class="n">ctx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shotgun_url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;//&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># project-only, e.g &#39;Project foobar&#39;</span>
            <span class="n">ctx_name</span> <span class="o">=</span> <span class="s2">&quot;Project </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># entity only</span>
            <span class="c1"># e.g. Shot ABC_123</span>

            <span class="c1"># resolve custom entities to their real display</span>
            <span class="n">entity_display_name</span> <span class="o">=</span> <span class="n">shotgun</span><span class="o">.</span><span class="n">get_entity_type_display_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">ctx_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">entity_display_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we have either step or task</span>
            <span class="n">task_step</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
                <span class="n">task_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">:</span>
                <span class="n">task_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>

            <span class="c1"># e.g. Lighting, Shot ABC_123</span>

            <span class="c1"># resolve custom entities to their real display</span>
            <span class="n">entity_display_name</span> <span class="o">=</span> <span class="n">shotgun</span><span class="o">.</span><span class="n">get_entity_type_display_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">ctx_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">task_step</span><span class="p">,</span>
                <span class="n">entity_display_name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ctx_name</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if this Context instance is equal to the other Context instance</span>

<span class="sd">        :param other:   The other Context instance to compare with</span>
<span class="sd">        :returns:       True if self represents the same context as other,</span>
<span class="sd">                        otherwise False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_entity_dicts_eq</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Test to see if two entity dictionaries are equal.  They are considered</span>
<span class="sd">            equal if both are dictionaries containing &#39;type&#39; and &#39;id&#39; with the same</span>
<span class="sd">            values for both keys, For example:</span>

<span class="sd">            Comparing these two dictionaries would return True:</span>
<span class="sd">            - {&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:123, &quot;foo&quot;:&quot;foo&quot;}</span>
<span class="sd">            - {&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:123, &quot;foo&quot;:&quot;bar&quot;, &quot;bar&quot;:&quot;foo&quot;}</span>

<span class="sd">            But comparing these two dictionaries would return False:</span>
<span class="sd">            - {&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:123, &quot;foo&quot;:&quot;foo&quot;}</span>
<span class="sd">            - {&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:567, &quot;foo&quot;:&quot;foo&quot;}</span>

<span class="sd">            :param d1:  First entity dictionary</span>
<span class="sd">            :param d2:  Second entity dictionary</span>
<span class="sd">            :returns:   True if d1 and d2 are considered equal, otherwise False.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">d1</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">d2</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">d2</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">d2</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Context</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">project</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">entity</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">step</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">task</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># compare additional entities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">additional_entities</span><span class="p">:</span>
            <span class="c1"># compare type, id tuples of all additional entities to ensure they are exactly the same.</span>
            <span class="c1"># this compare ignores duplicates in either list and just ensures that the intersection</span>
            <span class="c1"># of both lists contains all unique elements from both lists.</span>
            <span class="n">types_and_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span> <span class="k">if</span> <span class="n">e</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">other_types_and_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">additional_entities</span> <span class="k">if</span> <span class="n">e</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">types_and_ids</span> <span class="o">!=</span> <span class="n">other_types_and_ids</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">additional_entities</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># finally compare the user - this may result in a Shotgun look-up</span>
        <span class="c1"># so do this last!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">user</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if this Context instance is not equal to the other Context instance</span>

<span class="sd">        :param other:   The other Context instance to compare with</span>
<span class="sd">        :returns:       True if self != other, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_equal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_equal</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">is_equal</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a unique hash for the Context.</span>

<span class="sd">        :returns: int hash for this Context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use sort_keys to ensure dict order does not affect hash.</span>
        <span class="c1"># This hash is only guaranteed to be stable within a Python session,</span>
        <span class="c1"># however this is expected behavior for __hash__.</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow Context objects to be deepcopied - Note that the tk</span>
<span class="sd">        member is _never_ copied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># construct copy with current api instance:</span>
        <span class="n">ctx_copy</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">)</span>

        <span class="c1"># deepcopy all other members:</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__project</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__project</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__entity</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__entity</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__step</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__step</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__task</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__task</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__user</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__user</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__additional_entities</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__additional_entities</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__source_entity</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__source_entity</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>

        <span class="c1"># except:</span>
        <span class="c1"># ctx_copy._entity_fields_cache</span>

        <span class="k">return</span> <span class="n">ctx_copy</span>

    <span class="c1">################################################################################################</span>
    <span class="c1"># properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shotgun project associated with this context.</span>

<span class="sd">        If the context is incomplete, it is possible that the property is None. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Light/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.project</span>
<span class="sd">            {&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 4, &#39;name&#39;: &#39;demo_project&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__project</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">entity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shotgun entity associated with this context.</span>

<span class="sd">        If the context is incomplete, it is possible that the property is None. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Light/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.entity</span>
<span class="sd">            {&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: 412, &#39;name&#39;: &#39;ABC&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__entity</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">source_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Shotgun entity that was used to construct this Context.</span>

<span class="sd">        This is not necessarily the same as the context&#39;s &quot;entity&quot;, as there</span>
<span class="sd">        are situations where a context is interpreted from an input entity,</span>
<span class="sd">        such as when a PublishedFile entity is used to determine a context. In</span>
<span class="sd">        that case, the original PublishedFile becomes the source_entity, and</span>
<span class="sd">        project, entity, task, and step are determined by what the</span>
<span class="sd">        PublishedFile entity is linked to. A specific example of where this is</span>
<span class="sd">        useful is in a pick_environment core hook. In that hook, an environment</span>
<span class="sd">        is determined based on a provided Context object. In the case where we want</span>
<span class="sd">        to provide a specific environment for a Context built from a PublishedFile</span>
<span class="sd">        entity, the context&#39;s source_entity can be used to know for certain that it</span>
<span class="sd">        was constructured from a PublishedFile.</span>

<span class="sd">        :returns: A Shotgun entity dictionary.</span>
<span class="sd">        :rtype: dict or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__source_entity</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shotgun step associated with this context.</span>

<span class="sd">        If the context is incomplete, it is possible that the property is None. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Light/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.step</span>
<span class="sd">            {&#39;type&#39;: &#39;Step&#39;, &#39;id&#39;: 12, &#39;name&#39;: &#39;Light&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__step</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shotgun task associated with this context.</span>

<span class="sd">        If the context is incomplete, it is possible that the property is None. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/first_pass_lgt/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.task</span>
<span class="sd">            {&#39;type&#39;: &#39;Task&#39;, &#39;id&#39;: 212, &#39;name&#39;: &#39;first_pass_lgt&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__task</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A property which holds the user associated with this context.</span>
<span class="sd">        If the context is incomplete, it is possible that the property is None.</span>

<span class="sd">        The user property is special - either it represents a user value that was baked</span>
<span class="sd">        into a template path upon folder creation, or it represents the current user::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/dirk.gently/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.user</span>
<span class="sd">            {&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 23, &#39;name&#39;: &#39;Dirk Gently&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE! get_shotgun_user returns more fields than just type, id and name</span>
        <span class="c1"># so make sure we get rid of those. We should make sure we return the data</span>
        <span class="c1"># in a consistent way, similar to all other entities. No more. No less.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__user</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">user</span> <span class="o">=</span> <span class="n">login</span><span class="o">.</span><span class="n">get_current_user</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__user</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span>
                <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__user</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">additional_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of entities that are required to provide a full context in non-standard configurations.</span>
<span class="sd">        The &quot;context_additional_entities&quot; core hook gives the context construction code hints about how</span>
<span class="sd">        this data should be populated.</span>

<span class="sd">        .. warning:: This is an old and advanced option and may be deprecated in the future. We strongly</span>
<span class="sd">                     recommend not using it.</span>

<span class="sd">        :returns: A list of std shotgun link dictionaries.</span>
<span class="sd">                  Will be an empty list in most cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__additional_entities</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">entity_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of paths on disk which correspond to the **entity** which this context represents.</span>
<span class="sd">        If no folders have been created for this context yet, the value of this property will be an empty list::</span>


<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_entity(&quot;Task&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; ctx.entity_locations</span>
<span class="sd">            [&#39;/studio.08/demo_project/sequences/AAA/ABC&#39;]</span>

<span class="sd">        :returns: A list of paths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">paths_from_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">paths</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shotgun_url</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shotgun detail page url that best represents this context. Depending on</span>
<span class="sd">        the context, this may be a task, a shot, an asset or a project. If the context is</span>
<span class="sd">        completely empty, the root url of the associated shotgun installation is returned.</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_entity(&quot;Task&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; ctx.shotgun_url</span>
<span class="sd">            &#39;https://mystudio.shotgunstudio.com/detail/Task/8&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># walk up task -&gt; entity -&gt; project -&gt; site</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/detail/</span><span class="si">%s</span><span class="s2">/</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">,</span> <span class="s2">&quot;Task&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/detail/</span><span class="si">%s</span><span class="s2">/</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/detail/</span><span class="si">%s</span><span class="s2">/</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">,</span>
                <span class="s2">&quot;Project&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="c1"># fall back on just the site main url</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun_url</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filesystem_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A property which holds a list of paths on disk which correspond to this context.</span>
<span class="sd">        If no folders have been created for this context yet, the value of this property will be an empty list::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_entity(&quot;Task&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; ctx.filesystem_locations</span>
<span class="sd">            [&#39;/studio.08/demo_project/sequences/AAA/ABC/light/initial_pass&#39;]</span>

<span class="sd">        :returns: A list of paths</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first handle special cases: empty context</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># first handle special cases: project context</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">paths_from_entity</span><span class="p">(</span><span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

        <span class="c1"># at this stage we know that the context contains an entity</span>
        <span class="c1"># start off with all the paths matching this entity and then cull it down</span>
        <span class="c1"># based on constraints.</span>
        <span class="n">entity_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">paths_from_entity</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># for each of these paths, get the context and compare it against our context</span>
        <span class="c1"># todo: optimize this!</span>
        <span class="n">matching_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">entity_paths</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">context_from_path</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="c1"># the stuff we need to compare against are all the &quot;child&quot; levels</span>
            <span class="c1"># below entity: task and user</span>
            <span class="n">matching</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># no user data in either context</span>
                <span class="n">matching</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">ctx</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># both contexts have user data - is it matching?</span>
                <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]:</span>
                    <span class="n">matching</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">matching</span><span class="p">:</span>
                <span class="c1"># ok so user looks good, now check task.</span>
                <span class="c1"># it is possible that with a context that comes from shotgun</span>
                <span class="c1"># there is a task populated which is not being used in the file system</span>
                <span class="c1"># so when we compare tasks, only if there are differing task ids,</span>
                <span class="c1"># we should treat it as a mismatch.</span>
                <span class="n">task_matching</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]:</span>
                        <span class="n">task_matching</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">task_matching</span><span class="p">:</span>
                    <span class="c1"># both user and task is matching</span>
                    <span class="n">matching_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matching_paths</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sgtk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Toolkit API instance associated with this context</span>

<span class="sd">        :returns: :class:`Sgtk`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Legacy equivalent of :meth:`sgtk`</span>

<span class="sd">        :returns: :class:`Sgtk`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span>

    <span class="c1">################################################################################################</span>
    <span class="c1"># public methods</span>

<div class="viewcode-block" id="Context.as_template_fields"><a class="viewcode-back" href="../../core.html#sgtk.Context.as_template_fields">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">as_template_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the context object as a dictionary of template fields.</span>

<span class="sd">        This is useful if you want to use a Context object as part of a call to</span>
<span class="sd">        the Sgtk API. In order for the system to pass suitable values, you need to</span>
<span class="sd">        pass the template you intend to use the data with as a parameter to this method.</span>
<span class="sd">        The values are derived from existing paths on disk, or in the case of keys with</span>
<span class="sd">        shotgun_entity_type and shotgun_entity_field settings, direct queries to the Shotgun</span>
<span class="sd">        server. The validate parameter can be used to ensure that the method returns all</span>
<span class="sd">        context fields required by the template and if it can&#39;t then a :class:`TankError` will be raised.</span>
<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>

<span class="sd">            # Create a template based on a path on disk. Because this path has been</span>
<span class="sd">            # generated through Toolkit&#39;s folder processing and there are corresponding</span>
<span class="sd">            # FilesystemLocation entities stored in Shotgun, the context can resolve</span>
<span class="sd">            # the path into a set of Shotgun entities.</span>
<span class="sd">            #</span>
<span class="sd">            # Note how the context object, once resolved, does not contain</span>
<span class="sd">            # any information about the sequence associated with the Shot.</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.project</span>
<span class="sd">            {&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 4, &#39;name&#39;: &#39;demo_project&#39;}</span>
<span class="sd">            &gt;&gt;&gt; ctx.entity</span>
<span class="sd">            {&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: 2, &#39;name&#39;: &#39;ABC&#39;}</span>
<span class="sd">            &gt;&gt;&gt; ctx.step</span>
<span class="sd">            {&#39;type&#39;: &#39;Step&#39;, &#39;id&#39;: 1, &#39;name&#39;: &#39;Light&#39;}</span>

<span class="sd">            # now if we have a template object that we want to turn into a path,</span>
<span class="sd">            # we can request that the context object attempts to resolve as many</span>
<span class="sd">            # fields as it can. These fields can then be plugged into the template</span>
<span class="sd">            # object to generate a path on disk</span>
<span class="sd">            &gt;&gt;&gt; templ = tk.templates[&quot;maya_shot_publish&quot;]</span>
<span class="sd">            &gt;&gt;&gt; templ</span>
<span class="sd">            &lt;Sgtk TemplatePath maya_shot_publish: sequences/{Sequence}/{Shot}/{Step}/publish/{name}.v{version}.ma&gt;</span>

<span class="sd">            &gt;&gt;&gt; fields = ctx.as_template_fields(templ)</span>
<span class="sd">            &gt;&gt;&gt; fields</span>
<span class="sd">            {&#39;Step&#39;: &#39;Lighting&#39;, &#39;Shot&#39;: &#39;ABC&#39;, &#39;Sequence&#39;: &#39;AAA&#39;}</span>

<span class="sd">            # the fields dictionary above contains all the &#39;high level&#39; data that is necessary to realise</span>
<span class="sd">            # the template path. An app or integration can now go ahead and populate the fields specific</span>
<span class="sd">            # for the app&#39;s business logic - in this case name and version - and resolve the fields dictionary</span>
<span class="sd">            # data into a path.</span>


<span class="sd">        :param template:    :class:`Template` for which the fields will be used.</span>
<span class="sd">        :param validate:    If True then the fields found will be checked to ensure that all expected fields for</span>
<span class="sd">                            the context were found.  If a field is missing then a :class:`TankError` will be raised</span>
<span class="sd">        :returns:           A dictionary of template files representing the context. Handy to pass to for example</span>
<span class="sd">                            :meth:`Template.apply_fields`.</span>
<span class="sd">        :raises:            :class:`TankError` if the fields can&#39;t be resolved for some reason or if &#39;validate&#39; is True</span>
<span class="sd">                            and any of the context fields for the template weren&#39;t found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get all entities into a dictionary</span>
        <span class="n">entities</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="s2">&quot;Step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="s2">&quot;Task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="s2">&quot;HumanUser&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="s2">&quot;Project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span>

        <span class="c1"># If there are any additional entities, use them as long as they don&#39;t</span>
        <span class="c1"># conflict with types we already have values for (Step, Task, Shot/Asset/etc)</span>
        <span class="k">for</span> <span class="n">add_entity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">add_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
                <span class="n">entities</span><span class="p">[</span><span class="n">add_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">add_entity</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Try to populate fields using paths caches for entity</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">TemplatePath</span><span class="p">):</span>

            <span class="c1"># first, sanity check that we actually have a path cache entry</span>
            <span class="c1"># this relates to ticket 22541 where it is possible to create</span>
            <span class="c1"># a context object purely from Shotgun without having it in the path cache</span>
            <span class="c1"># (using tk.context_from_entity(Task, 1234) for example)</span>
            <span class="c1">#</span>
            <span class="c1"># Such a context can result in erronous lookups in the later commands</span>
            <span class="c1"># since these make the assumption that the path cache contains the information</span>
            <span class="c1"># that is being saught after.</span>
            <span class="c1">#</span>
            <span class="c1"># therefore, if the context object contains an entity object and this entity is</span>
            <span class="c1"># not represented in the path cache, raise an exception.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity_locations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># context has an entity associated but no path cache entries</span>
                <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot resolve template data for context &#39;</span><span class="si">%s</span><span class="s2">&#39; - this context &quot;</span>
                    <span class="s2">&quot;does not have any associated folders created on disk yet and &quot;</span>
                    <span class="s2">&quot;therefore no template data can be extracted. Please run the folder &quot;</span>
                    <span class="s2">&quot;creation for </span><span class="si">%s</span><span class="s2"> and try again!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># first look at which ENTITY paths are associated with this context object</span>
            <span class="c1"># and use these to extract the right fields for this template</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields_from_entity_paths</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

            <span class="c1"># filter the list of fields to just those that don&#39;t have a &#39;None&#39; value.</span>
            <span class="c1"># Note: A &#39;None&#39; value for a field indicates an ambiguity and was set in the</span>
            <span class="c1"># _fields_from_entity_paths method (!)</span>
            <span class="n">non_none_fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">fields</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Determine additional field values by walking down the template tree</span>
            <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fields_from_template_tree</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">non_none_fields</span><span class="p">,</span> <span class="n">entities</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># get values for shotgun query keys in template</span>
        <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields_from_shotgun</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">entities</span><span class="p">,</span> <span class="n">validate</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">validate</span><span class="p">:</span>
            <span class="c1"># check that all context template fields were found and if not then raise a TankError</span>
            <span class="n">missing_fields</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key_name</span> <span class="ow">in</span> <span class="n">template</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key_name</span> <span class="ow">in</span> <span class="n">entities</span> <span class="ow">and</span> <span class="n">key_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                    <span class="c1"># we have a template key that should have been found but wasn&#39;t!</span>
                    <span class="n">missing_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">missing_fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot resolve template fields for context &#39;</span><span class="si">%s</span><span class="s2">&#39; - the following &quot;</span>
                    <span class="s2">&quot;keys could not be resolved: &#39;</span><span class="si">%s</span><span class="s2">&#39;.  Please run the folder creation &quot;</span>
                    <span class="s2">&quot;for &#39;</span><span class="si">%s</span><span class="s2">&#39; and try again!&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_fields</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">fields</span></div>

<div class="viewcode-block" id="Context.create_copy_for_user"><a class="viewcode-back" href="../../core.html#sgtk.Context.create_copy_for_user">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">create_copy_for_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides the ability to create a copy of an existing Context for a specific user.</span>

<span class="sd">        This is useful if you need to determine a user specific version of a path, e.g.</span>
<span class="sd">        when copying files between different user sandboxes. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/dirk.gently/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.user</span>
<span class="sd">            {&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 23, &#39;name&#39;: &#39;Dirk Gently&#39;}</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; copied_ctx = tk.create_copy_for_user({&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 7, &#39;name&#39;: &#39;John Snow&#39;})</span>
<span class="sd">            &gt;&gt;&gt; copied_ctx.user</span>
<span class="sd">            {&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 23, &#39;name&#39;: &#39;John Snow&#39;}</span>

<span class="sd">        :param user:  The Shotgun user entity dictionary that should be set on the copied context</span>
<span class="sd">        :returns: :class:`Context`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ctx_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__user</span> <span class="o">=</span> <span class="n">user</span>
        <span class="k">return</span> <span class="n">ctx_copy</span></div>

    <span class="c1">################################################################################################</span>
    <span class="c1"># serialization</span>

<div class="viewcode-block" id="Context.serialize"><a class="viewcode-back" href="../../core.html#sgtk.Context.serialize">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_user_credentials</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_json</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serializes the context into a string.</span>

<span class="sd">        Any Context object can be serialized to/deserialized from a string.</span>
<span class="sd">        This can be useful if you need to pass a Context between different processes.</span>
<span class="sd">        As an example, the ``tk-multi-launchapp`` uses this mechanism to pass the Context</span>
<span class="sd">        from the launch process (e.g. for example PTR desktop app) to the</span>
<span class="sd">        Application (e.g. Maya) being launched. Example:</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/dirk.gently/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; context_str = ctx.serialize(ctx)</span>
<span class="sd">            &gt;&gt;&gt; new_ctx = sgtk.Context.deserialize(context_str)</span>

<span class="sd">        :param with_user_credentials: If ``True``, the currently authenticated user&#39;s credentials, as</span>
<span class="sd">            returned by :meth:`sgtk.get_authenticated_user`, will also be serialized with the context.</span>

<span class="sd">        :param use_json: If ``True``, the context will be stored in the JSON representation</span>
<span class="sd">            instead of using the pickled representation.</span>

<span class="sd">        .. note:: For example, credentials should be omitted (``with_user_credentials=False``) when</span>
<span class="sd">            serializing the context from a user&#39;s current session to send it to a render farm. By doing</span>
<span class="sd">            so, invoking :meth:`sgtk.Context.deserialize` on the render farm will only restore the</span>
<span class="sd">            context and not the authenticated user.</span>

<span class="sd">        :returns: String representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoids cyclic imports</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.api</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_authenticated_user</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tank</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">with_user_credentials</span><span class="p">:</span>
            <span class="c1"># If there is an authenticated user.</span>
            <span class="n">user</span> <span class="o">=</span> <span class="n">get_authenticated_user</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
                <span class="c1"># We should serialize it as well so that the next process knows who to</span>
                <span class="c1"># run as.</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_current_user&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">authentication</span><span class="o">.</span><span class="n">serialize_user</span><span class="p">(</span>
                    <span class="n">user</span><span class="p">,</span> <span class="n">use_json</span><span class="o">=</span><span class="n">use_json</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">use_json</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Context.deserialize"><a class="viewcode-back" href="../../core.html#sgtk.Context.deserialize">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">deserialize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">context_str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The inverse of :meth:`Context.serialize`.</span>

<span class="sd">        :param context_str: String representation of context, created with :meth:`Context.serialize`</span>

<span class="sd">        .. note:: If the context was serialized with the user credentials, the currently authenticated</span>
<span class="sd">            user will be updated with these credentials.</span>

<span class="sd">        :returns: :class:`Context`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># lazy load this to avoid cyclic dependencies</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.api</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tank</span><span class="p">,</span> <span class="n">set_authenticated_user</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If the serialized payload starts with a {, we have a</span>
            <span class="c1"># JSON-encoded string.</span>
            <span class="k">if</span> <span class="n">context_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;{&quot;</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">context_str</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">context_str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TankContextDeserializationError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

        <span class="c1"># first get the pipeline config path out of the dict</span>
        <span class="n">pipeline_config_path</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span>

        <span class="c1"># Authentication in Toolkit requires that credentials are passed from</span>
        <span class="c1"># one process to another so the currently authenticated user is carried</span>
        <span class="c1"># from one process to another. The current user needs to be part of the</span>
        <span class="c1"># context because multiple DCCs can run at the same time under different</span>
        <span class="c1"># users, e.g. launching Maya from the site as user A and Nuke from the tank</span>
        <span class="c1"># command as user B.</span>
        <span class="n">user_string</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_current_user&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">user_string</span><span class="p">:</span>
            <span class="c1"># Remove it from the data</span>
            <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_current_user&quot;</span><span class="p">]</span>
            <span class="c1"># and set the authenticated user user.</span>
            <span class="n">user</span> <span class="o">=</span> <span class="n">authentication</span><span class="o">.</span><span class="n">deserialize_user</span><span class="p">(</span><span class="n">user_string</span><span class="p">)</span>
            <span class="n">set_authenticated_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

        <span class="c1"># create a Sgtk API instance.</span>
        <span class="n">tk</span> <span class="o">=</span> <span class="n">Tank</span><span class="p">(</span><span class="n">pipeline_config_path</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tk</span>

        <span class="c1"># add it to the constructor instance</span>
        <span class="c1"># and lastly make the obejct</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Context.to_dict"><a class="viewcode-back" href="../../core.html#sgtk.Context.to_dict">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the context into a dictionary with keys ``project``,</span>
<span class="sd">        ``entity``, ``user``, ``step``, ``task``, ``additional_entities`` and</span>
<span class="sd">        ``source_entity``.</span>

<span class="sd">        .. note ::</span>
<span class="sd">            Contrary to :meth:`Context.serialize`, this method discards information</span>
<span class="sd">            about the Toolkit instance associated with the context or the currently</span>
<span class="sd">            authenticated user.</span>

<span class="sd">        :returns: A dictionary representing the context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">),</span>
            <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">),</span>
            <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">),</span>
            <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">),</span>
            <span class="s2">&quot;task&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">),</span>
            <span class="s2">&quot;additional_entities&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_entity</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span> <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span>
            <span class="p">],</span>
            <span class="s2">&quot;source_entity&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_entity</span><span class="p">),</span>
        <span class="p">}</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_cleanup_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cleanup the entity dictionary.</span>

<span class="sd">        :param dict entity: Shotgun entity object.</span>

<span class="sd">        On Python 3, we have to be very careful about what we pickle because if we start</span>
<span class="sd">        serializing non-builtin types like datetimes we won&#39;t be able to cast back the pickle</span>
<span class="sd">        into a string and we won&#39;t be able to use those values in environment variables.</span>

<span class="sd">        Because of this, we will keep the smallest amount of fields we need for the context.</span>
<span class="sd">        This is the type, id, name and the actual real name field for the entity</span>
<span class="sd">        (code, content, etc...)</span>

<span class="sd">        :returns: Dictionary with keys id and type and optionally name and the entity&#39;s</span>
<span class="sd">            real name field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">entity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">filtered_entity</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]}</span>
        <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">entity</span><span class="p">:</span>
            <span class="n">filtered_entity</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">filtered_entity</span>

<div class="viewcode-block" id="Context.from_dict"><a class="viewcode-back" href="../../core.html#sgtk.Context.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a dictionary into a :class:`Context` object.</span>

<span class="sd">        You should only pass in a dictionary that was created with the :meth:`Context.to_dict`</span>
<span class="sd">        method.</span>

<span class="sd">        :param dict data: A dictionary generated from :meth:`Context.to_dict`.</span>
<span class="sd">        :param tk: Toolkit instance to associate with the context.</span>
<span class="sd">        :type tk: :class:`Sgtk`</span>

<span class="sd">        :returns: A newly created :class:`Context` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tk</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Context object based on the arguments found in a dictionary, but</span>
<span class="sd">        only the ones that the Context understands.</span>

<span class="sd">        This ensures that if a more recent version of Toolkit serializes a context</span>
<span class="sd">        and this API reads it that it won&#39;t blow-up.</span>

<span class="sd">        :param dict data: Data for the context.</span>

<span class="sd">        :returns: :class:`Context`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Context</span><span class="p">(</span>
            <span class="n">tk</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tk&quot;</span><span class="p">),</span>
            <span class="n">project</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;project&quot;</span><span class="p">),</span>
            <span class="n">entity</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity&quot;</span><span class="p">),</span>
            <span class="n">step</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">),</span>
            <span class="n">task</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">),</span>
            <span class="n">user</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;user&quot;</span><span class="p">),</span>
            <span class="n">additional_entities</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">),</span>
            <span class="n">source_entity</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;source_entity&quot;</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="c1">################################################################################################</span>
    <span class="c1"># private methods</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fields_from_shotgun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">entities</span><span class="p">,</span> <span class="n">validate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Query Shotgun server for keys used by this template whose values come directly</span>
<span class="sd">        from Shotgun fields.</span>

<span class="sd">        :param template: Template to retrieve Shotgun fields for.</span>
<span class="sd">        :param entities: Dictionary of entities for the current context.</span>
<span class="sd">        :param validate: If True, missing fields will raise a TankError.</span>

<span class="sd">        :returns: Dictionary of field values extracted from Shotgun.</span>
<span class="sd">        :rtype: dict</span>

<span class="sd">        :raises TankError: Raised if a key is missing from the entities list when ``validate`` is ``True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># for any sg query field</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">template</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>

            <span class="c1"># check each key to see if it has shotgun query information that we should resolve</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">:</span>
                <span class="c1"># this key is a shotgun value that needs fetching!</span>

                <span class="c1"># ensure that the context actually provides the desired entities</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">validate</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                            <span class="s2">&quot;Key &#39;</span><span class="si">%s</span><span class="s2">&#39; in template &#39;</span><span class="si">%s</span><span class="s2">&#39; could not be populated by &quot;</span>
                            <span class="s2">&quot;context &#39;</span><span class="si">%s</span><span class="s2">&#39; because the context does not contain a &quot;</span>
                            <span class="s2">&quot;PTR entity of type &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="n">entity</span> <span class="o">=</span> <span class="n">entities</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span><span class="p">]</span>

                <span class="c1"># check the context cache</span>
                <span class="n">cache_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_fields_cache</span><span class="p">:</span>
                    <span class="c1"># already have the value cached - no need to fetch from shotgun</span>
                    <span class="n">fields</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_fields_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># get the value from shotgun</span>
                    <span class="n">filters</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]]]</span>
                    <span class="n">query_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span>
                        <span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">query_fields</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="c1"># no record with that id in shotgun!</span>
                        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                            <span class="s2">&quot;Could not retrieve PTR data for key &#39;</span><span class="si">%s</span><span class="s2">&#39; in &quot;</span>
                            <span class="s2">&quot;template &#39;</span><span class="si">%s</span><span class="s2">&#39;. No records in PTR are matching &quot;</span>
                            <span class="s2">&quot;entity &#39;</span><span class="si">%s</span><span class="s2">&#39; (Which is part of the current &quot;</span>
                            <span class="s2">&quot;context &#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                        <span class="p">)</span>

                    <span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">)</span>

                    <span class="c1"># note! It is perfectly possible (and may be valid) to return None values from</span>
                    <span class="c1"># shotgun at this point. In these cases, a None field will be returned in the</span>
                    <span class="c1"># fields dictionary from as_template_fields, and this may be injected into</span>
                    <span class="c1"># a template with optional fields.</span>

                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">processed_val</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="k">else</span><span class="p">:</span>

                        <span class="c1"># now convert the shotgun value to a string.</span>
                        <span class="c1"># note! This means that there is no way currently to create an int key</span>
                        <span class="c1"># in a tank template which matches an int field in shotgun, since we are</span>
                        <span class="c1"># force converting everything into strings...</span>

                        <span class="n">processed_val</span> <span class="o">=</span> <span class="n">shotgun_entity</span><span class="o">.</span><span class="n">sg_entity_to_string</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">,</span>
                            <span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span><span class="p">,</span>
                            <span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">),</span>
                            <span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">,</span>
                            <span class="n">value</span><span class="p">,</span>
                        <span class="p">)</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">processed_val</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                                <span class="s2">&quot;Template validation failed for value &#39;</span><span class="si">%s</span><span class="s2">&#39;. This &quot;</span>
                                <span class="s2">&quot;value was retrieved from entity </span><span class="si">%s</span><span class="s2"> in PTR to &quot;</span>
                                <span class="s2">&quot;represent key &#39;</span><span class="si">%s</span><span class="s2">&#39; in &quot;</span>
                                <span class="s2">&quot;template &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                                <span class="o">%</span> <span class="p">(</span><span class="n">processed_val</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
                            <span class="p">)</span>

                    <span class="c1"># all good!</span>
                    <span class="c1"># populate dictionary and cache</span>
                    <span class="n">fields</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">processed_val</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_entity_fields_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">processed_val</span>

        <span class="k">return</span> <span class="n">fields</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fields_from_entity_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines a template&#39;s key values based on context by walking up the context entities paths until</span>
<span class="sd">        matches for the template are found.</span>

<span class="sd">        :param template:    The template to find fields for</span>
<span class="sd">        :returns:           A dictionary of field name, value pairs for any fields found for the template</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">project_roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_project_roots</span><span class="p">()</span>

        <span class="c1"># get all locations on disk for our context object from the path cache</span>
        <span class="n">path_cache_locations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_locations</span>

        <span class="c1"># now loop over all those locations and check if one of the locations</span>
        <span class="c1"># are matching the template that is passed in. In that case, try to</span>
        <span class="c1"># extract the fields values.</span>
        <span class="k">for</span> <span class="n">cur_path</span> <span class="ow">in</span> <span class="n">path_cache_locations</span><span class="p">:</span>
            <span class="n">previous_path</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># walk up path until we reach the project root and get values</span>
            <span class="k">while</span> <span class="n">cur_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">project_roots</span><span class="p">:</span>
                <span class="n">cur_fields</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">validate_and_get_fields</span><span class="p">(</span><span class="n">cur_path</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cur_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># If there are conflicts, there is ambiguity in the schema</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">cur_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                            <span class="c1"># Value is ambiguous for this key</span>
                            <span class="n">cur_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cur_fields</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cur_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">cur_path</span><span class="p">)</span>

                    <span class="c1"># On some platforms, os.path.dirname might preserve a trailing slash on UNC paths,</span>
                    <span class="c1"># which could interfere with field extraction logic. This ensures the path is normalized.</span>
                    <span class="k">if</span> <span class="n">cur_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">):</span>
                        <span class="n">cur_path</span> <span class="o">=</span> <span class="n">cur_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="c1"># We really should never be in this case now with the fix above, but</span>
                    <span class="c1"># just in case, we&#39;ll raise here if it looks like we&#39;re just looping</span>
                    <span class="c1"># over the same path multiple times. This will also make our tests</span>
                    <span class="c1"># fail in a reasonable way if there&#39;s a problem rather than just</span>
                    <span class="c1"># hanging up forever until the process is killed.</span>
                    <span class="k">if</span> <span class="n">cur_path</span> <span class="o">==</span> <span class="n">previous_path</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                            <span class="s2">&quot;There was a problem parsing an entity location to determine &quot;</span>
                            <span class="s2">&quot;its project root. The path in question is </span><span class="si">%s</span><span class="s2">, and the &quot;</span>
                            <span class="s2">&quot;project&#39;s roots are </span><span class="si">%s</span><span class="s2">. This problem would have resulted in &quot;</span>
                            <span class="s2">&quot;an infinite loop, but has now been stopped.&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">cur_path</span><span class="p">,</span> <span class="n">project_roots</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">previous_path</span> <span class="o">=</span> <span class="n">cur_path</span>

        <span class="k">return</span> <span class="n">fields</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fields_from_template_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">known_fields</span><span class="p">,</span> <span class="n">context_entities</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines values for a template&#39;s keys based on the context by walking down the template tree</span>
<span class="sd">        matching template keys with entity types.</span>

<span class="sd">        This method attempts to find as many fields as possible from the path cache but will try to ensure</span>
<span class="sd">        that incorrect fields are never returned, even if the path cache is not 100% clean (e.g. contains</span>
<span class="sd">        out-of-date paths for one or more of the entities in the context).</span>

<span class="sd">        :param template:            The template to find fields for</span>
<span class="sd">        :param known_fields:        Dictionary of fields that are already known for this template.  The</span>
<span class="sd">                                    logic in this method will ensure that any fields found match these.</span>
<span class="sd">        :param context_entities:    A dictionary of {entity_type:entity_dict} that contains all the entities</span>
<span class="sd">                                    belonging to this context.</span>
<span class="sd">        :returns:                   A dictionary of all fields found by this method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1 - Walk up the template tree and collect templates</span>
        <span class="c1">#</span>
        <span class="c1"># Use cached paths to find field values</span>
        <span class="c1"># these will be returned in top-down order:</span>
        <span class="c1"># [&lt;Sgtk TemplatePath sequences/{Sequence}&gt;,</span>
        <span class="c1">#  &lt;Sgtk TemplatePath sequences/{Sequence}/{Shot}&gt;,</span>
        <span class="c1">#  &lt;Sgtk TemplatePath sequences/{Sequence}/{Shot}/{Step}&gt;,</span>
        <span class="c1">#  &lt;Sgtk TemplatePath sequences/{Sequence}/{Shot}/{Step}/publish&gt;,</span>
        <span class="c1">#  &lt;Sgtk TemplatePath sequences/{Sequence}/{Shot}/{Step}/publish/maya&gt;,</span>
        <span class="c1">#  &lt;Sgtk TemplatePath maya_shot_publish: sequences/{Sequence}/{Shot}/{Step}/publish/maya/{name}.v{version}.ma&gt;]</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="n">_get_template_ancestors</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

        <span class="c1"># Step 2 - walk templates from the root down.</span>
        <span class="c1"># for each template, get all paths we have stored in the database and find any fields we can for it, making</span>
        <span class="c1"># sure that none of the found fields conflict with the list of entities provided to this method</span>
        <span class="c1">#</span>
        <span class="c1"># build up a list of fields as we go so that each level matches</span>
        <span class="c1"># at least the fields from all previous levels</span>
        <span class="n">found_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># get a path cache handle</span>
        <span class="n">path_cache</span> <span class="o">=</span> <span class="n">PathCache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">templates</span><span class="p">:</span>
                <span class="c1"># iterate over all keys in the list of keys for the template</span>
                <span class="c1"># from lowest to highest looking for any that represent context</span>
                <span class="c1"># entities (key name == entity type)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">ordered_keys</span><span class="p">):</span>
                    <span class="n">key_name</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">name</span>
                    <span class="c1"># Check to see if we already have a value for this key:</span>
                    <span class="k">if</span> <span class="n">key_name</span> <span class="ow">in</span> <span class="n">known_fields</span> <span class="ow">or</span> <span class="n">key_name</span> <span class="ow">in</span> <span class="n">found_fields</span><span class="p">:</span>
                        <span class="c1"># already have a value so skip</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">key_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">context_entities</span><span class="p">:</span>
                        <span class="c1"># key doesn&#39;t represent an entity so skip</span>
                        <span class="k">continue</span>

                    <span class="c1"># find fields for any paths associated with this entity by looking in the path cache:</span>
                    <span class="n">entity_fields</span> <span class="o">=</span> <span class="n">_values_from_path_cache</span><span class="p">(</span>
                        <span class="n">context_entities</span><span class="p">[</span><span class="n">key_name</span><span class="p">],</span>
                        <span class="n">template</span><span class="p">,</span>
                        <span class="n">path_cache</span><span class="p">,</span>
                        <span class="n">required_fields</span><span class="o">=</span><span class="n">found_fields</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># entity_fields may contain additional fields that correspond to entities</span>
                    <span class="c1"># so we should be sure to validate these as well if we can.</span>
                    <span class="c1">#</span>
                    <span class="c1"># The following example illustrates where the code could previously return incorrect entity</span>
                    <span class="c1"># information from this method:</span>
                    <span class="c1">#</span>
                    <span class="c1"># With the following template:</span>
                    <span class="c1">#    /{Sequence}/{Shot}/{Step}</span>
                    <span class="c1">#</span>
                    <span class="c1"># And a path cache that contains:</span>
                    <span class="c1">#    Type     | Id  | Name     | Path</span>
                    <span class="c1">#    ----------------------------------------------------</span>
                    <span class="c1">#    Sequence | 001 | Seq_001  | /Seq_001</span>
                    <span class="c1">#    Shot     | 002 | Shot_A   | /Seq_001/Shot_A</span>
                    <span class="c1">#    Step     | 003 | Lighting | /Seq_001/Shot_A/Lighting</span>
                    <span class="c1">#    Step     | 003 | Lighting | /Seq_001/blah/Shot_B/Lighting   &lt;- this is out of date!</span>
                    <span class="c1">#    Shot     | 004 | Shot_B   | /Seq_001/blah/Shot_B            &lt;- this is out of date!</span>
                    <span class="c1">#</span>
                    <span class="c1"># (Note: the schema/templates have been changed since the entries for Shot_b were added)</span>
                    <span class="c1">#</span>
                    <span class="c1"># The sub-templates used to search for fields are:</span>
                    <span class="c1">#    /{Sequence}</span>
                    <span class="c1">#    /{Sequence}/{Shot}</span>
                    <span class="c1">#    /{Sequence}/{Shot}/{Step}</span>
                    <span class="c1">#</span>
                    <span class="c1"># And the entities passed into the method are:</span>
                    <span class="c1">#    Sequence:   Seq_001</span>
                    <span class="c1">#    Shot:       Shot_B</span>
                    <span class="c1">#    Step:       Lighting</span>
                    <span class="c1">#</span>
                    <span class="c1"># We are searching for fields for &#39;Shot_B&#39; that has a broken entry in the path cache so the fields</span>
                    <span class="c1"># returned for each level of the template will be:</span>
                    <span class="c1">#    /{Sequence}                 -&gt; {&quot;Sequence&quot;:&quot;Seq_001&quot;} &lt;- Correct</span>
                    <span class="c1">#    /{Sequence}/{Shot}          -&gt; {}                     &lt;- entry not found for Shot_B matching</span>
                    <span class="c1">#                                                             the template</span>
                    <span class="c1">#    /{Sequence}/{Shot}/{Step}   -&gt; {&quot;Sequence&quot;:&quot;Seq_001&quot;, &lt;- Correct</span>
                    <span class="c1">#                                    &quot;Shot&quot;:&quot;Shot_A&quot;,      &lt;- Wrong!</span>
                    <span class="c1">#                                    &quot;Step&quot;:&quot;Lighting&quot;}    &lt;- Correct</span>
                    <span class="c1">#</span>
                    <span class="c1"># In previous implementations, the final fields would incorrectly be returned as:</span>
                    <span class="c1">#</span>
                    <span class="c1">#     {&quot;Sequence&quot;:&quot;Seq_001&quot;,</span>
                    <span class="c1">#      &quot;Shot&quot;:&quot;Shot_A&quot;,</span>
                    <span class="c1">#      &quot;Step&quot;:&quot;Lighting&quot;}</span>
                    <span class="c1">#</span>
                    <span class="c1"># The wrong Shot (Shot_A) is returned and not caught because the code only tested that the Step</span>
                    <span class="c1"># entity matches and just assumes that the rest is correct - this isn&#39;t the case when there is</span>
                    <span class="c1"># a one-to-many relationship between entities!</span>
                    <span class="c1">#</span>
                    <span class="c1"># Therefore, we need to validate that we didn&#39;t find any entity fields that we should have found</span>
                    <span class="c1"># previously/higher up in the template definition.  If we did then the entries that were found</span>
                    <span class="c1"># may not be correct so we have to discard them!</span>
                    <span class="n">found_mismatching_field</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_value</span> <span class="ow">in</span> <span class="n">entity_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">known_fields</span><span class="p">:</span>
                            <span class="c1"># We found a field we already knew about...</span>
                            <span class="k">if</span> <span class="n">field_value</span> <span class="o">!=</span> <span class="n">known_fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]:</span>
                                <span class="c1"># ...but it doesn&#39;t match!</span>
                                <span class="n">found_mismatching_field</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">elif</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">found_fields</span><span class="p">:</span>
                            <span class="c1"># We found a field we found before...</span>
                            <span class="k">if</span> <span class="n">field_value</span> <span class="o">!=</span> <span class="n">found_fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]:</span>
                                <span class="c1"># ...but it doesn&#39;t match!</span>
                                <span class="n">found_mismatching_field</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">elif</span> <span class="n">field_name</span> <span class="o">==</span> <span class="n">key_name</span><span class="p">:</span>
                            <span class="c1"># We found a field that matches the entity we were searching for so it must be valid!</span>
                            <span class="n">found_fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_value</span>
                        <span class="k">elif</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">context_entities</span><span class="p">:</span>
                            <span class="c1"># We found an entity type that we should have found before (in a previous/shorter</span>
                            <span class="c1"># template).  This means we can&#39;t trust any other fields that were found as they</span>
                            <span class="c1"># may belong to a completely different entity/path!</span>
                            <span class="n">found_mismatching_field</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_mismatching_field</span><span class="p">:</span>
                        <span class="c1"># all fields are ok so we can add them all to the list of found fields :)</span>
                        <span class="n">found_fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">entity_fields</span><span class="p">)</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="n">path_cache</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">found_fields</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_project_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the project root paths for the current pipeline configuration.</span>

<span class="sd">        :returns: A list of project root file paths as strings.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_data_roots</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>


<span class="c1">################################################################################################</span>
<span class="c1"># factory methods for constructing new Context objects, primarily called from the Tank object</span>


<span class="k">def</span><span class="w"> </span><span class="nf">create_empty</span><span class="p">(</span><span class="n">tk</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs an empty context.</span>

<span class="sd">    :returns: a context object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="n">tk</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">from_entity</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a context from a shotgun entity.</span>

<span class="sd">    For more information, see :meth:`Sgtk.context_from_entity`.</span>

<span class="sd">    :param tk:           Sgtk API handle</span>
<span class="sd">    :param entity_type:  The shotgun entity type to produce a context for</span>
<span class="sd">    :param entity_id:    The shotgun entity id to produce a context for</span>

<span class="sd">    :returns: :class:`Context`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_from_entity_type_and_id</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">entity_type</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">entity_id</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_from_entity_type_and_id</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="n">source_entity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a context from the entity type and id as stored in the given</span>
<span class="sd">    entity. Any other data necessary to construct the context beyond the type</span>
<span class="sd">    and id keys will be queried from Shotgun. To get a context from a fully</span>
<span class="sd">    populated entity dictionary, see the from_entity_dictionary function.</span>

<span class="sd">    For more information, see :meth:`Sgtk.context_from_entity`.</span>

<span class="sd">    :param tk: Sgtk API handle</span>
<span class="sd">    :param dict entity: The entity to construct the context from, containing</span>
<span class="sd">        a minimum of type and id keys.</span>
<span class="sd">    :param dict source_entity: The entity dictionary to add to the context</span>
<span class="sd">        as its source_entity. The source entity can be different from the entity,</span>
<span class="sd">        which is useful in the situation where a context is being built from</span>
<span class="sd">        what the source entity is linked to, but its desirable to maintain</span>
<span class="sd">        a reference back to the original entity. A specific example of when</span>
<span class="sd">        this is used is for PublishedFile entities, where the Context object</span>
<span class="sd">        represents the location in the pipeline of what the PublishedFile is</span>
<span class="sd">        linked to. In that situation, we store the original PublishedFile entity</span>
<span class="sd">        as the source entity, which can then be used in a pick_environment hook</span>
<span class="sd">        to return a specific environment for PublishedFiles.</span>

<span class="sd">    :returns: :class:`Context`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">entity_type</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
    <span class="n">entity_id</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">entity_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot create a context from an entity type &#39;None&#39;!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">entity_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot create a context from an entity id set to &#39;None&#39;!&quot;</span><span class="p">)</span>

    <span class="c1"># prep our return data structure</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;tk&quot;</span><span class="p">:</span> <span class="n">tk</span><span class="p">,</span>
        <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;task&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;additional_entities&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s2">&quot;source_entity&quot;</span><span class="p">:</span> <span class="n">source_entity</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Task&quot;</span><span class="p">:</span>
        <span class="c1"># For tasks get data from shotgun query</span>
        <span class="n">task_context</span> <span class="o">=</span> <span class="n">_task_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">task_context</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">entity_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PublishedFile&quot;</span><span class="p">,</span> <span class="s2">&quot;TankPublishedFile&quot;</span><span class="p">]:</span>

        <span class="n">sg_entity</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span>
            <span class="n">entity_type</span><span class="p">,</span> <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">]],</span> <span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">,</span> <span class="s2">&quot;entity&quot;</span><span class="p">,</span> <span class="s2">&quot;task&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">sg_entity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                <span class="s2">&quot;Entity </span><span class="si">%s</span><span class="s2"> with id </span><span class="si">%s</span><span class="s2"> not found in Flow Production Tracking!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">sg_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">):</span>
            <span class="c1"># base the context on the task for the published file</span>
            <span class="k">return</span> <span class="n">_from_entity_type_and_id</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">sg_entity</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">],</span> <span class="n">sg_entity</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">sg_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity&quot;</span><span class="p">):</span>
            <span class="c1"># base the context on the entity that the published is linked with</span>
            <span class="k">return</span> <span class="n">_from_entity_type_and_id</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">sg_entity</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">],</span> <span class="n">sg_entity</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">sg_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;project&quot;</span><span class="p">):</span>
            <span class="c1"># base the context on the project that the published is linked with</span>
            <span class="k">return</span> <span class="n">_from_entity_type_and_id</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">sg_entity</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">],</span> <span class="n">sg_entity</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Get data from path cache</span>
        <span class="n">entity_context</span> <span class="o">=</span> <span class="n">_context_data_from_cache</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>

        <span class="c1"># make sure this was actually found in the cache</span>
        <span class="c1"># fall back on a shotgun lookup if not found</span>
        <span class="k">if</span> <span class="n">entity_context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entity_context</span> <span class="o">=</span> <span class="n">_entity_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>

        <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">entity_context</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
            <span class="c1"># no need to set entity to point at project in this case</span>
            <span class="c1"># that only produces double entries.</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># If there isn&#39;t an explicit source_entity, we set it to be</span>
    <span class="c1"># the same as the entity property.</span>
    <span class="n">context</span><span class="p">[</span><span class="s2">&quot;source_entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;source_entity&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">Context</span><span class="o">.</span><span class="n">_from_dict</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">from_entity_dictionary</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a context from a shotgun entity dictionary.</span>

<span class="sd">    For more information, see :meth:`Sgtk.context_from_entity_dictionary`.</span>

<span class="sd">    :param tk: :class:`Sgtk`</span>
<span class="sd">    :param dict entity_dictionary: The entity dictionary to create the context from</span>
<span class="sd">        containing at least: {&quot;type&quot;:entity_type, &quot;id&quot;:entity_id}</span>

<span class="sd">    :returns: :class:`Context`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_from_entity_dictionary</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_from_entity_dictionary</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">,</span> <span class="n">source_entity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a context from a Shotgun entity dictionary.</span>

<span class="sd">    For more information, see :meth:`Sgtk.context_from_entity_dictionary`.</span>

<span class="sd">    :param tk: :class:`Sgtk`</span>
<span class="sd">    :param entity_dictionary: The entity dictionary to create the context from</span>
<span class="sd">                              containing at least: {&quot;type&quot;:entity_type, &quot;id&quot;:entity_id}</span>
<span class="sd">    :param dict source_entity: The entity dictionary to add to the context</span>
<span class="sd">        as its source_entity. The source entity can be different from the entity,</span>
<span class="sd">        which is useful in the situation where a context is being built from</span>
<span class="sd">        what the source entity is linked to, but its desirable to maintain</span>
<span class="sd">        a reference back to the original entity. A specific example of when</span>
<span class="sd">        this is used is for PublishedFile entities, where the Context object</span>
<span class="sd">        represents the location in the pipeline of what the PublishedFile is</span>
<span class="sd">        linked to. In that situation, we store the original PublishedFile entity</span>
<span class="sd">        as the source entity, which can then be used in a pick_environment hook</span>
<span class="sd">        to return a specific environment for PublishedFiles.</span>

<span class="sd">    :returns: :class:`Context`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># perform validation of the entity dictionary:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entity_dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot create a context from an empty or invalid entity dictionary!&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entity_dictionary</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot create a context without an entity type!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entity_dictionary</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot create a context without an entity id!&quot;</span><span class="p">)</span>

    <span class="c1"># prep our context data structure</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;tk&quot;</span><span class="p">:</span> <span class="n">tk</span><span class="p">,</span>
        <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;task&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;additional_entities&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s2">&quot;source_entity&quot;</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">source_entity</span> <span class="ow">or</span> <span class="n">entity_dictionary</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">entity_type</span> <span class="o">=</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
    <span class="n">entity_id</span> <span class="o">=</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>

    <span class="c1"># try to determine the various entities from the entity dictionary:</span>
    <span class="n">project</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">entity</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">step</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
        <span class="c1"># find entities for a project context</span>
        <span class="n">project</span> <span class="o">=</span> <span class="n">entity_dictionary</span>
    <span class="k">elif</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Task&quot;</span><span class="p">:</span>
        <span class="c1"># find entities for a task context</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">entity_dictionary</span>
        <span class="k">if</span> <span class="s2">&quot;project&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">task</span> <span class="ow">or</span> <span class="s2">&quot;entity&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">task</span> <span class="ow">or</span> <span class="s2">&quot;step&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">project</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">entity_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PublishedFile&quot;</span><span class="p">,</span> <span class="s2">&quot;TankPublishedFile&quot;</span><span class="p">]:</span>
        <span class="c1"># special case handling for published files:</span>
        <span class="k">if</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">):</span>
            <span class="c1"># construct a task context</span>
            <span class="k">return</span> <span class="n">_from_entity_dictionary</span><span class="p">(</span>
                <span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">],</span> <span class="n">source_entity</span><span class="o">=</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;source_entity&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity&quot;</span><span class="p">):</span>
            <span class="c1"># construct an entity context</span>
            <span class="k">return</span> <span class="n">_from_entity_dictionary</span><span class="p">(</span>
                <span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">],</span> <span class="n">source_entity</span><span class="o">=</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;source_entity&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;project&quot;</span><span class="p">):</span>
            <span class="c1"># construct project context</span>
            <span class="k">return</span> <span class="n">_from_entity_dictionary</span><span class="p">(</span>
                <span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">],</span> <span class="n">source_entity</span><span class="o">=</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;source_entity&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># fall back on from_entity:</span>
            <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># find entities for an entity context</span>
        <span class="n">entity</span> <span class="o">=</span> <span class="n">entity_dictionary</span>
        <span class="k">if</span> <span class="s2">&quot;project&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entity</span><span class="p">:</span>
            <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">project</span> <span class="o">=</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">fallback_to_ctx_from_entity</span><span class="p">:</span>
        <span class="c1"># clean up entities and populate context structure:</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_build_clean_entity</span><span class="p">(</span><span class="n">ent</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Ensure entity has id, type and name fields and build a clean</span>
<span class="sd">            entity dictionary containing just those fields to return, stripping</span>
<span class="sd">            out all other fields.</span>

<span class="sd">            :param ent: The entity dictionary to build a clean dictionary from</span>
<span class="sd">            :returns:   A clean entity dictionary containing just &#39;type&#39;, &#39;id&#39;</span>
<span class="sd">                        and &#39;name&#39; if all three exist in the input dictionary</span>
<span class="sd">                        or None if they don&#39;t.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># make sure we have id, type and name:</span>
            <span class="k">if</span> <span class="s2">&quot;id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ent</span> <span class="ow">or</span> <span class="s2">&quot;type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ent</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">ent_name</span> <span class="o">=</span> <span class="n">_get_entity_name</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ent_name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># return a clean dictionary:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">ent</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">ent</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">ent_name</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">project</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_clean_entity</span><span class="p">(</span><span class="n">project</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]:</span>
                <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fallback_to_ctx_from_entity</span> <span class="ow">and</span> <span class="n">entity</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_clean_entity</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]:</span>
                <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fallback_to_ctx_from_entity</span> <span class="ow">and</span> <span class="n">step</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_clean_entity</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]:</span>
                <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fallback_to_ctx_from_entity</span> <span class="ow">and</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_clean_entity</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]:</span>
                <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">fallback_to_ctx_from_entity</span><span class="p">:</span>
        <span class="c1"># entity dict doesn&#39;t contain enough information to build a</span>
        <span class="c1"># safe, valid context so fall back on &#39;from_entity&#39;:</span>
        <span class="k">return</span> <span class="n">_from_entity_type_and_id</span><span class="p">(</span>
            <span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">,</span> <span class="n">source_entity</span><span class="o">=</span><span class="n">context</span><span class="p">[</span><span class="s2">&quot;source_entity&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
        <span class="c1"># one final check if we have a task:</span>
        <span class="n">additional_fields</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook</span><span class="p">(</span><span class="s2">&quot;context_additional_entities&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;entity_fields_on_task&quot;</span><span class="p">,</span> <span class="p">[]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">additional_fields</span><span class="p">:</span>
            <span class="c1"># unfortunately we have to fall back to an sg query to get the additional entities :(</span>
            <span class="n">task_context</span> <span class="o">=</span> <span class="n">_task_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">additional_fields</span><span class="p">)</span>
            <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">task_context</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Context</span><span class="o">.</span><span class="n">_from_dict</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">from_path</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">previous_context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory method that constructs a context object from a path on disk.</span>

<span class="sd">    The algorithm will navigate upwards in the file system and collect</span>
<span class="sd">    as much tank metadata as possible to construct a Tank context.</span>

<span class="sd">    :param path: a file system path</span>
<span class="sd">    :param previous_context: A context object to use to try to automatically extend the generated</span>
<span class="sd">                             context if it is incomplete when extracted from the path. For example,</span>
<span class="sd">                             the Task may be carried across from the previous context if it is</span>
<span class="sd">                             suitable and if the task wasn&#39;t already expressed in the file system</span>
<span class="sd">                             path passed in via the path argument.</span>
<span class="sd">    :type previous_context: :class:`Context`</span>
<span class="sd">    :returns: :class:`Context`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># prep our return data structure</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;tk&quot;</span><span class="p">:</span> <span class="n">tk</span><span class="p">,</span>
        <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;task&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;additional_entities&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="p">}</span>

    <span class="c1"># ask hook for extra entity types we should recognize and insert into the additional_entities list.</span>
    <span class="n">additional_types</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook</span><span class="p">(</span><span class="s2">&quot;context_additional_entities&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;entity_types_in_path&quot;</span><span class="p">,</span> <span class="p">[]</span>
    <span class="p">)</span>

    <span class="c1"># get a cache handle</span>
    <span class="n">path_cache</span> <span class="o">=</span> <span class="n">PathCache</span><span class="p">(</span><span class="n">tk</span><span class="p">)</span>

    <span class="c1"># gather all roots as lower case</span>
    <span class="n">project_roots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_data_roots</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="p">]</span>

    <span class="c1"># first gather entities</span>
    <span class="n">entities</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">secondary_entities</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr_path</span> <span class="o">=</span> <span class="n">path</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">curr_entity</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_entity</span><span class="p">(</span><span class="n">curr_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr_entity</span><span class="p">:</span>
            <span class="c1"># Don&#39;t worry about entity types we&#39;ve already got in the context. In the future</span>
            <span class="c1"># we should look for entity ids that conflict in order to flag a degenerate schema.</span>
            <span class="n">entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_entity</span><span class="p">)</span>

        <span class="c1"># add secondary entities</span>
        <span class="n">secondary_entities</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">path_cache</span><span class="o">.</span><span class="n">get_secondary_entities</span><span class="p">(</span><span class="n">curr_path</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">curr_path</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">project_roots</span><span class="p">:</span>
            <span class="c1"># TODO this could fail with windows path variations</span>
            <span class="c1"># we have reached a root!</span>
            <span class="k">break</span>

        <span class="c1"># and continue with parent path</span>
        <span class="n">parent_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">curr_path</span><span class="p">,</span> <span class="s2">&quot;..&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">curr_path</span> <span class="o">==</span> <span class="n">parent_path</span><span class="p">:</span>
            <span class="c1"># We&#39;re at the disk root, probably a degenerate path</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_path</span> <span class="o">=</span> <span class="n">parent_path</span>

    <span class="n">path_cache</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># now populate the context</span>
    <span class="c1"># go from the root down, so that in the case there are a path with</span>
    <span class="c1"># multiple entities (like PROJECT/SEQUENCE/SHOT), the last entry</span>
    <span class="c1"># is the most relevant one, and will be assigned as the entity</span>
    <span class="k">for</span> <span class="n">curr_entity</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># handle the special context fields first</span>
        <span class="k">if</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Step&quot;</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Task&quot;</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;HumanUser&quot;</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">additional_types</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_entity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

    <span class="c1"># now that the context has been populated as much as possible using the</span>
    <span class="c1"># primary entities, fill in any blanks based on the secondary entities.</span>
    <span class="k">for</span> <span class="n">curr_entity</span> <span class="ow">in</span> <span class="n">secondary_entities</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># handle the special context fields first</span>
        <span class="k">if</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Step&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Task&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;HumanUser&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">additional_types</span><span class="p">:</span>
            <span class="c1"># is this entity in the list already</span>
            <span class="k">if</span> <span class="n">curr_entity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">]:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_entity</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

    <span class="c1"># see if we can populate it based on the previous context</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">previous_context</span>
        <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">entity</span>
        <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">additional_entities</span>
    <span class="p">):</span>

        <span class="c1"># cool, everything is matching down to the step/task level.</span>
        <span class="c1"># if context is missing a step and a task, we try to auto populate it.</span>
        <span class="c1"># (note: weird edge that a context can have a task but no step)</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">step</span>

        <span class="c1"># now try to assign previous task but only if the step matches!</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">task</span>

    <span class="c1"># ensure that we don&#39;t have a Project as the entity. Projects should only</span>
    <span class="c1"># appear on the projects level, despite being entities.</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span>
        <span class="ow">and</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span>
        <span class="ow">and</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span>
    <span class="p">):</span>
        <span class="c1"># remove double entry!</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">Context</span><span class="o">.</span><span class="n">_from_dict</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>


<span class="c1">################################################################################################</span>
<span class="c1"># serialization</span>


<span class="k">def</span><span class="w"> </span><span class="nf">serialize</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Serializes the context into a string.</span>

<span class="sd">    .. deprecated:: v0.18.12</span>
<span class="sd">       Use :meth:`Context.serialize`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">deserialize</span><span class="p">(</span><span class="n">context_str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The inverse of :meth:`serialize`.</span>

<span class="sd">    .. deprecated:: v0.18.12</span>
<span class="sd">       Use :meth:`Context.deserialize`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Context</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">context_str</span><span class="p">)</span>


<span class="c1">################################################################################################</span>
<span class="c1"># YAML representer/constructor</span>


<span class="k">def</span><span class="w"> </span><span class="nf">context_yaml_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom serializer.</span>
<span class="sd">    Creates yaml code for a context object.</span>

<span class="sd">    Legacy, kept for compatibility reasons, can probably be removed at this point.</span>

<span class="sd">    .. note:: Contrary to :meth:`sgtk.Context.serialize`, this method doesn&#39;t serialize the</span>
<span class="sd">        currently authenticated user.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># first get the stuff which represents all the Context()</span>
    <span class="c1"># constructor parameters</span>
    <span class="n">context_dict</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

    <span class="c1"># now we also need to pass a TK instance to the constructor when we</span>
    <span class="c1"># are deserializing the object. For this purpose, pass a</span>
    <span class="c1"># pipeline config path as part of the dict</span>
    <span class="n">context_dict</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">tank</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_mapping</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;!TankContext&quot;</span><span class="p">,</span> <span class="n">context_dict</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">context_yaml_constructor</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom deserializer.</span>
<span class="sd">    Constructs a context object given the yaml data provided.</span>

<span class="sd">    Legacy, kept for compatibility reasons, can probably be removed at this point.</span>

<span class="sd">    .. note:: Contrary to :meth:`sgtk.Context.deserialize`, this method doesn&#39;t can&#39;t restore the</span>
<span class="sd">        currently authenticated user.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># lazy load this to avoid cyclic dependencies</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.api</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tank</span>

    <span class="c1"># get the dict from yaml</span>
    <span class="n">context_constructor_dict</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">construct_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># first get the pipeline config path out of the dict</span>
    <span class="n">pipeline_config_path</span> <span class="o">=</span> <span class="n">context_constructor_dict</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">context_constructor_dict</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span>

    <span class="c1"># create a Sgtk API instance.</span>
    <span class="n">tk</span> <span class="o">=</span> <span class="n">Tank</span><span class="p">(</span><span class="n">pipeline_config_path</span><span class="p">)</span>
    <span class="n">context_constructor_dict</span><span class="p">[</span><span class="s2">&quot;tk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tk</span>
    <span class="c1"># and lastly make the object</span>
    <span class="k">return</span> <span class="n">Context</span><span class="o">.</span><span class="n">_from_dict</span><span class="p">(</span><span class="n">context_constructor_dict</span><span class="p">)</span>


<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">Context</span><span class="p">,</span> <span class="n">context_yaml_representer</span><span class="p">)</span>
<span class="n">yaml</span><span class="o">.</span><span class="n">add_constructor</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;!TankContext&quot;</span><span class="p">,</span> <span class="n">context_yaml_constructor</span><span class="p">)</span>

<span class="c1">################################################################################################</span>
<span class="c1"># utility methods</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_entity_name</span><span class="p">(</span><span class="n">entity_dictionary</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract the entity name from the specified entity dictionary if it can</span>
<span class="sd">    be found.  The entity dictionary must contain at least &#39;type&#39;</span>

<span class="sd">    :param entity_dictionary:   An entity dictionary to extract the name from</span>
<span class="sd">    :returns:                   The name of the entity if found in the entity</span>
<span class="sd">                                dictionary, otherwise None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name_field</span> <span class="o">=</span> <span class="n">shotgun_entity</span><span class="o">.</span><span class="n">get_sg_entity_name_field</span><span class="p">(</span><span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
    <span class="n">entity_name</span> <span class="o">=</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name_field</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">entity_name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Also check to see if entity contains &#39;name&#39;:</span>
        <span class="k">if</span> <span class="n">name_field</span> <span class="o">!=</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
            <span class="n">entity_name</span> <span class="o">=</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">entity_name</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_task_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">task_id</span><span class="p">,</span> <span class="n">additional_fields</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a context from a shotgun task.</span>
<span class="sd">    Because we are constructing the context from a task, we will get a context</span>
<span class="sd">    which has both a project, an entity a step and a task associated with it.</span>

<span class="sd">    Manne 9 April 2013: could we use the path cache primarily and fall back onto</span>
<span class="sd">                        a shotgun lookup?</span>

<span class="sd">    :param tk:                   An Sgtk API instance</span>
<span class="sd">    :param task_id:              The shotgun task id to produce a context for.</span>
<span class="sd">    :param additional_fields:    List of additional fields to query for additional entities.  If this is</span>
<span class="sd">                                &#39;None&#39; then the function will execute the hook to determine them.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Look up task&#39;s step and entity. This information should be static in practice, so we could</span>
    <span class="c1"># likely cache it in the future.</span>

    <span class="n">standard_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;content&quot;</span><span class="p">,</span> <span class="s2">&quot;entity&quot;</span><span class="p">,</span> <span class="s2">&quot;step&quot;</span><span class="p">,</span> <span class="s2">&quot;project&quot;</span><span class="p">]</span>
    <span class="c1"># theses keys map directly to linked entities, users will be handled separately</span>
    <span class="n">context_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">,</span> <span class="s2">&quot;entity&quot;</span><span class="p">,</span> <span class="s2">&quot;step&quot;</span><span class="p">,</span> <span class="s2">&quot;task&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">additional_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># ask hook for extra Task entity fields we should query and insert into the additional_entities list.</span>
        <span class="n">additional_fields</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook</span><span class="p">(</span><span class="s2">&quot;context_additional_entities&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;entity_fields_on_task&quot;</span><span class="p">,</span> <span class="p">[]</span>
        <span class="p">)</span>

    <span class="n">task</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span>
        <span class="s2">&quot;Task&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">task_id</span><span class="p">]],</span> <span class="n">standard_fields</span> <span class="o">+</span> <span class="n">additional_fields</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Unable to locate Task with id </span><span class="si">%s</span><span class="s2"> in Flow Production Tracking&quot;</span> <span class="o">%</span> <span class="n">task_id</span><span class="p">)</span>

    <span class="c1"># add task so it can be processed with other shotgun entities</span>
    <span class="n">task</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Task&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">task_id</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;content&quot;</span><span class="p">]}</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">context_keys</span> <span class="o">+</span> <span class="n">additional_fields</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># gracefully skip stuff we don&#39;t have</span>
            <span class="c1"># for example tasks may not have a step</span>
            <span class="k">continue</span>

        <span class="c1"># be explicit about what we pull in - make no assumptions about what is</span>
        <span class="c1"># being returned from sg (the unit tests mocker doesn&#39;t return the same as the API)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">),</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">context_keys</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">additional_fields</span><span class="p">:</span>
            <span class="n">additional_entities</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">additional_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">additional_entities</span>

    <span class="k">return</span> <span class="n">context</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_entity_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the entity details for the specified entity type and id by querying Shotgun.</span>

<span class="sd">    If entity_type is &#39;Project&#39; then this will return a single dictionary for the project.  For all</span>
<span class="sd">    other entity types, this will return dictionaries for both the entity and the project the entity</span>
<span class="sd">    exists under.</span>

<span class="sd">    :param tk:          The sgtk api instance</span>
<span class="sd">    :param entity_type: The entity type to build a context for</span>
<span class="sd">    :param entity_id:   The entity id to build a context for</span>
<span class="sd">    :returns:           Dictionary containing either a project entity-dictionary or both</span>
<span class="sd">                        project and entity entity-dictionaries depending on the input entity type.</span>
<span class="sd">                        e.g.</span>
<span class="sd">                        {</span>
<span class="sd">                            &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;, &quot;id&quot;:123, &quot;name&quot;:&quot;My Project&quot;},</span>
<span class="sd">                            &quot;entity&quot;:{&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:456, &quot;name&quot;:&quot;My Shot&quot;}</span>
<span class="sd">                        }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the sg name field for the specified entity type:</span>
    <span class="n">name_field</span> <span class="o">=</span> <span class="n">shotgun_entity</span><span class="o">.</span><span class="n">get_sg_entity_name_field</span><span class="p">(</span><span class="n">entity_type</span><span class="p">)</span>

    <span class="c1"># get the entity data from Shotgun</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span>
        <span class="n">entity_type</span><span class="p">,</span> <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">]],</span> <span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">,</span> <span class="n">name_field</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
            <span class="s2">&quot;Unable to locate </span><span class="si">%s</span><span class="s2"> with id </span><span class="si">%s</span><span class="s2"> in Flow Production Tracking&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># create context</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Project&quot;</span><span class="p">,</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">entity_id</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name_field</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">entity_type</span><span class="p">,</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">entity_id</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name_field</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;project&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">context</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_context_data_from_cache</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds data to context based on path cache.</span>

<span class="sd">    :param tk: a Sgtk API instance</span>
<span class="sd">    :param entity_type: a Shotgun entity type</span>
<span class="sd">    :param entity_id: a Shotgun entity id</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Set entity info for input entity</span>
    <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">entity_type</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">entity_id</span><span class="p">}</span>

    <span class="c1"># Map entity types to context fields</span>
    <span class="n">types_fields</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Project&quot;</span><span class="p">:</span> <span class="s2">&quot;project&quot;</span><span class="p">,</span> <span class="s2">&quot;Step&quot;</span><span class="p">:</span> <span class="s2">&quot;step&quot;</span><span class="p">,</span> <span class="s2">&quot;Task&quot;</span><span class="p">:</span> <span class="s2">&quot;task&quot;</span><span class="p">}</span>

    <span class="c1"># Use the path cache to look up all paths linked to the entity and use that to extract</span>
    <span class="c1"># extra entities we should include in the context</span>
    <span class="n">path_cache</span> <span class="o">=</span> <span class="n">PathCache</span><span class="p">(</span><span class="n">tk</span><span class="p">)</span>

    <span class="c1"># Grab all project roots</span>
    <span class="n">project_roots</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_data_roots</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="c1"># Special case for project as we have the primary data path, which</span>
    <span class="c1"># always points at a project. We only check if the associated configuration</span>
    <span class="c1"># has any associated data roots, otherwise a primary config won&#39;t exist.</span>
    <span class="k">if</span> <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">has_associated_data_roots</span><span class="p">():</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_entity</span><span class="p">(</span>
            <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_primary_data_root</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">paths</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_paths</span><span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">primary_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="c1"># now recurse upwards and look for entity types we haven&#39;t found yet</span>
        <span class="n">curr_path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="n">curr_entity</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_entity</span><span class="p">(</span><span class="n">curr_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">curr_entity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># this is some sort of anomaly! the path returned by get_paths</span>
            <span class="c1"># does not resolve in get_entity. This can happen if the storage</span>
            <span class="c1"># mappings are not consistent or if there is not a 1 to 1 relationship</span>
            <span class="c1">#</span>
            <span class="c1"># This can also happen if there are extra slashes at the end of the path</span>
            <span class="c1"># in the local storage defs and in the pipeline_configuration.yml file.</span>
            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span>
                <span class="s2">&quot;The path &#39;</span><span class="si">%s</span><span class="s2">&#39; associated with </span><span class="si">%s</span><span class="s2"> id </span><span class="si">%s</span><span class="s2"> does not &quot;</span>
                <span class="s2">&quot;resolve correctly. This may be an indication of an issue &quot;</span>
                <span class="s2">&quot;with the local storage setup. Please contact support at </span><span class="si">%s</span><span class="s2">.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">curr_path</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">SUPPORT_URL</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># grab the name for the context entity</span>
        <span class="k">if</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">entity_type</span> <span class="ow">and</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">entity_id</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

        <span class="c1"># note - paths returned by get_paths are always prefixed with a</span>
        <span class="c1"># project root so there is no risk we end up with an infinite loop here..</span>
        <span class="k">while</span> <span class="n">curr_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">project_roots</span><span class="p">:</span>
            <span class="n">curr_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">curr_path</span><span class="p">,</span> <span class="s2">&quot;..&quot;</span><span class="p">))</span>
            <span class="n">curr_entity</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_entity</span><span class="p">(</span><span class="n">curr_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr_entity</span><span class="p">:</span>
                <span class="n">cur_type</span> <span class="o">=</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cur_type</span> <span class="ow">in</span> <span class="n">types_fields</span><span class="p">:</span>
                    <span class="n">field_name</span> <span class="o">=</span> <span class="n">types_fields</span><span class="p">[</span><span class="n">cur_type</span><span class="p">]</span>
                    <span class="n">context</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

    <span class="n">path_cache</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">context</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_values_from_path_cache</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">cur_template</span><span class="p">,</span> <span class="n">path_cache</span><span class="p">,</span> <span class="n">required_fields</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine values for template fields based on an entities cached paths.</span>

<span class="sd">    :param entity:          The entity to search for fields for</span>
<span class="sd">    :param cur_template:    The template to use to search the path cache</span>
<span class="sd">    :path_cache:            An instance of the path_cache to search in</span>
<span class="sd">    :param required_fields: A list of fields that must exist in any matched path</span>
<span class="sd">    :return:                Dictionary of fields found by matching the template against all paths</span>
<span class="sd">                            found for the entity</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># use the databsae to go from shotgun type/id --&gt; paths</span>
    <span class="n">entity_paths</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_paths</span><span class="p">(</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">primary_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Mapping for field values found in conjunction with this entities paths</span>
    <span class="n">unique_fields</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># keys whose values should be removed from return values</span>
    <span class="n">remove_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">entity_paths</span><span class="p">:</span>

        <span class="c1"># validate path and get fields:</span>
        <span class="n">path_fields</span> <span class="o">=</span> <span class="n">cur_template</span><span class="o">.</span><span class="n">validate_and_get_fields</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">required_fields</span><span class="o">=</span><span class="n">required_fields</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path_fields</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Check values against those found for other paths</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">path_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">unique_fields</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">unique_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="c1"># value for this key isn&#39;t unique!</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]:</span>
                    <span class="c1"># Ambiguity for Entity key</span>
                    <span class="c1"># now it is possible that we have ambiguity here, but it is normally</span>
                    <span class="c1"># an edge case. For example imagine that an asset has paths</span>
                    <span class="c1"># /proj/hero_HIGH</span>
                    <span class="c1"># /proj/hero_LOW</span>
                    <span class="c1"># and we are mapping against template /%(Project)s/%(Asset)s</span>
                    <span class="c1"># both paths are valid matches, so we have ambiguous state for the entity</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Ambiguous data. Multiple paths cached for </span><span class="si">%s</span><span class="s2"> which match template </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entity</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_template</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># ambiguity for Static key</span>
                    <span class="n">unique_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">remove_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># we want to remove the None/ambiguous values so they don&#39;t interfere with other entities</span>
    <span class="k">for</span> <span class="n">remove_key</span> <span class="ow">in</span> <span class="n">remove_keys</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">unique_fields</span><span class="p">[</span><span class="n">remove_key</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">unique_fields</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_template_ancestors</span><span class="p">(</span><span class="n">template</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return templates branch of the template tree, ordered from first template</span>
<span class="sd">    below the project root down to and including the input template.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO this would probably be better as the Template&#39;s responsibility</span>
    <span class="n">templates</span> <span class="o">=</span> <span class="p">[</span><span class="n">template</span><span class="p">]</span>
    <span class="n">cur_template</span> <span class="o">=</span> <span class="n">template</span>
    <span class="k">while</span> <span class="n">cur_template</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_template</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">next_template</span> <span class="o">=</span> <span class="n">cur_template</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">templates</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">next_template</span><span class="p">)</span>
        <span class="n">cur_template</span> <span class="o">=</span> <span class="n">next_template</span>
    <span class="k">return</span> <span class="n">templates</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Autodesk.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 

  <script type="text/javascript">
    window.wafCCPAForceShow = true;
    (function(a,b,c,d){
      a='https://tags.tiqcdn.com/utag/autodesk/micro-basic/prod/utag.js';
      b=document;c='script';d=b.createElement(c);d.src=a;d.type='text/java'+c;d.async=true;
      a=b.getElementsByTagName(c)[0];a.parentNode.insertBefore(d,a);
    })();
  </script>


</body>
</html>




<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tank.context &mdash; tk-core v0.18.22 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="tk-core v0.18.22 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
    <a href='http://developer.shotgunsoftware.com'>
    
        <img style='width: 191px;
                height: 60px; 
                margin: 2px;
                border-radius: 0px; 
                padding: 0px;' 
            src='../../_static/logo@2x.png'/>
    
    </a>
    

          
            <a href="../../index.html" class="icon icon-home"> tk-core
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../bootstrap.html">Deploy and management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Foundation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platform.html">Apps, Engines and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../descriptor.html">Descriptor API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authentication.html">Authentication</a></li>
</ul>

            
          
       
    <div style='margin-top: 50px;
                margin-left: 10px;
                margin-right: 10px;
                padding: 10px; 
                color: #b3b3b3; 
                font-size: 70%;
                border-radius: 3px;
                background-color: #444;
                line-height: 18px;
                '>    
    <style>
        a.custom_post_menu { display: inline; 
                             padding: 0px; 
                             text-decoration: underline; }
    </style>

    <b>tk-core</b> v0.18.22.<br>
    
        This documentation is part of the Shotgun Pipeline Toolkit.
    
    For more information, please visit
    <a class=custom_post_menu href='https://support.shotgunsoftware.com/home'>Shotgun Support</a>.
    The code associated with this documentation can be found 
    <a class=custom_post_menu href='https://github.com/shotgunsoftware/tk-core'>here</a>.

    </div>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">tk-core</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>tank.context</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tank.context</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2013 Shotgun Software Inc.</span>
<span class="c1"># </span>
<span class="c1"># CONFIDENTIAL AND PROPRIETARY</span>
<span class="c1"># </span>
<span class="c1"># This work is provided &quot;AS IS&quot; and subject to the Shotgun Pipeline Toolkit </span>
<span class="c1"># Source Code License included in this distribution package. See LICENSE.</span>
<span class="c1"># By accessing, using, copying or modifying this work you indicate your </span>
<span class="c1"># agreement to the Shotgun Pipeline Toolkit Source Code License. All rights </span>
<span class="c1"># not expressly granted therein are reserved by Shotgun Software Inc.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Management of the current context, e.g. the current shotgun entity/step/task.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">tank_vendor</span> <span class="kn">import</span> <span class="n">yaml</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">authentication</span>

<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">login</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">shotgun_entity</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">shotgun</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">TankError</span><span class="p">,</span> <span class="n">TankContextDeserializationError</span>
<span class="kn">from</span> <span class="nn">.path_cache</span> <span class="kn">import</span> <span class="n">PathCache</span>
<span class="kn">from</span> <span class="nn">.template</span> <span class="kn">import</span> <span class="n">TemplatePath</span>


<div class="viewcode-block" id="Context"><a class="viewcode-back" href="../../core.html#sgtk.Context">[docs]</a><span class="k">class</span> <span class="nc">Context</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A context instance is used to collect a set of key fields describing the</span>
<span class="sd">    current Context. We sometimes refer to the context as the current work area.</span>
<span class="sd">    Typically this would be the current shot or asset that someone is working on.</span>

<span class="sd">    The context captures the current point in both shotgun and the file system and context</span>
<span class="sd">    objects are launch a toolkit engine via the :meth:`sgtk.platform.start_engine`</span>
<span class="sd">    method. The context points the engine to a particular</span>
<span class="sd">    point in shotgun and on disk - it could be something as detailed as a task inside a Shot,</span>
<span class="sd">    and something as vague as an empty context.</span>

<span class="sd">    The context is split up into several levels of granularity, reflecting the</span>
<span class="sd">    fundamental hierarchy of Shotgun itself.</span>

<span class="sd">    - The project level defines which shotgun project the context reflects.</span>
<span class="sd">    - The entity level defines which entity the context reflects. For example,</span>
<span class="sd">      this may be a Shot or an Asset. Note that in the case of a Shot, the context</span>
<span class="sd">      does not contain any direct information of which sequence the shot is linked to,</span>
<span class="sd">      however the context can still resolve such relationships implicitly if needed -</span>
<span class="sd">      typically via the :meth:`Context.as_context_fields` method.</span>
<span class="sd">    - The step level defines the current pipeline step. This is often a reflection of a</span>
<span class="sd">      department or a general step in a workflow or pipeline (e.g. Modeling, Rigging).</span>
<span class="sd">    - The task level defines a current Shotgun task.</span>
<span class="sd">    - The user level defines the current user.</span>

<span class="sd">    The data forms a hierarchy, so implicitly, the task belongs to the entity which in turn</span>
<span class="sd">    belongs to the project. The exception to this is the user, which simply reflects the</span>
<span class="sd">    currently operating user.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">entity</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">additional_entities</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Context objects are not constructed by hand but are fabricated by the</span>
<span class="sd">        methods :meth:`Sgtk.context_from_entity`, :meth:`Sgtk.context_from_entity_dictionary`</span>
<span class="sd">        and :meth:`Sgtk.context_from_path`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span> <span class="o">=</span> <span class="n">tk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__project</span> <span class="o">=</span> <span class="n">project</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__entity</span> <span class="o">=</span> <span class="n">entity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__step</span> <span class="o">=</span> <span class="n">step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__task</span> <span class="o">=</span> <span class="n">task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__user</span> <span class="o">=</span> <span class="n">user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__additional_entities</span> <span class="o">=</span> <span class="n">additional_entities</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_entity_fields_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># multi line repr</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Project: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__project</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Entity: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__entity</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Step: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__step</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Task: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__task</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  User: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__user</span><span class="p">))</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Shotgun URL: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">)</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Additional Entities: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__additional_entities</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="s2">&quot;&lt;Sgtk Context: </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># smart looking string representation</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># We&#39;re in a &quot;site&quot; context, so we&#39;ll give the site&#39;s url</span>
            <span class="c1"># minus the &quot;https://&quot; if that&#39;s attached.</span>
            <span class="n">ctx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shotgun_url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;//&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># project-only!</span>
            <span class="n">ctx_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># entity only</span>
            <span class="c1"># e.g. Shot ABC_123</span>
            
            <span class="c1"># resolve custom entities to their real display</span>
            <span class="n">entity_display_name</span> <span class="o">=</span> <span class="n">shotgun</span><span class="o">.</span><span class="n">get_entity_type_display_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">,</span> 
                                                                       <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">))</span>
            
            <span class="n">ctx_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">entity_display_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we have either step or task</span>
            <span class="n">task_step</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
                <span class="n">task_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">:</span>
                <span class="n">task_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
            
            <span class="c1"># e.g. Lighting, Shot ABC_123</span>
            
            <span class="c1"># resolve custom entities to their real display</span>
            <span class="n">entity_display_name</span> <span class="o">=</span> <span class="n">shotgun</span><span class="o">.</span><span class="n">get_entity_type_display_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">,</span> 
                                                                       <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">))</span>
            
            <span class="n">ctx_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">task_step</span><span class="p">,</span> 
                                      <span class="n">entity_display_name</span><span class="p">,</span> 
                                      <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">ctx_name</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if this Context instance is equal to the other Context instance</span>
<span class="sd">                        </span>
<span class="sd">        :param other:   The other Context instance to compare with</span>
<span class="sd">        :returns:       True if self represents the same context as other, </span>
<span class="sd">                        otherwise False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_entity_dicts_eq</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Test to see if two entity dictionaries are equal.  They are considered</span>
<span class="sd">            equal if both are dictionaries containing &#39;type&#39; and &#39;id&#39; with the same</span>
<span class="sd">            values for both keys, For example:</span>
<span class="sd">            </span>
<span class="sd">            Comparing these two dictionaries would return True:</span>
<span class="sd">            - {&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:123, &quot;foo&quot;:&quot;foo&quot;}</span>
<span class="sd">            - {&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:123, &quot;foo&quot;:&quot;bar&quot;, &quot;bar&quot;:&quot;foo&quot;}</span>
<span class="sd">            </span>
<span class="sd">            But comparing these two dictionaries would return False:</span>
<span class="sd">            - {&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:123, &quot;foo&quot;:&quot;foo&quot;}</span>
<span class="sd">            - {&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:567, &quot;foo&quot;:&quot;foo&quot;} </span>
<span class="sd">    </span>
<span class="sd">            :param d1:  First entity dictionary</span>
<span class="sd">            :param d2:  Second entity dictionary</span>
<span class="sd">            :returns:   True if d1 and d2 are considered equal, otherwise False.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">d1</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">d2</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">d2</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">d2</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>        
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Context</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">project</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">entity</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">step</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">task</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="c1"># compare additional entities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">additional_entities</span><span class="p">:</span>
            <span class="c1"># compare type, id tuples of all additional entities to ensure they are exactly the same.</span>
            <span class="c1"># this compare ignores duplicates in either list and just ensures that the intersection</span>
            <span class="c1"># of both lists contains all unique elements from both lists. </span>
            <span class="n">types_and_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span> <span class="k">if</span> <span class="n">e</span><span class="p">])</span>
            <span class="n">other_types_and_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">additional_entities</span> <span class="k">if</span> <span class="n">e</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">types_and_ids</span> <span class="o">!=</span> <span class="n">other_types_and_ids</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">additional_entities</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># finally compare the user - this may result in a Shotgun look-up </span>
        <span class="c1"># so do this last!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_entity_dicts_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">user</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="k">return</span> <span class="bp">True</span> 

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if this Context instance is not equal to the other Context instance</span>
<span class="sd">                        </span>
<span class="sd">        :param other:   The other Context instance to compare with</span>
<span class="sd">        :returns:       True if self != other, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">is_equal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_equal</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">is_equal</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow Context objects to be deepcopied - Note that the tk</span>
<span class="sd">        member is _never_ copied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># construct copy with current api instance:</span>
        <span class="n">ctx_copy</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">)</span>
        
        <span class="c1"># deepcopy all other members:</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__project</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__project</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__entity</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__entity</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__step</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__step</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__task</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__task</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__user</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__user</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>        
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__additional_entities</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__additional_entities</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        
        <span class="c1"># except:</span>
        <span class="c1"># ctx_copy._entity_fields_cache</span>
        
        <span class="k">return</span> <span class="n">ctx_copy</span>

    <span class="c1">################################################################################################</span>
    <span class="c1"># properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shotgun project associated with this context.</span>

<span class="sd">        If the context is incomplete, it is possible that the property is None. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Light/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.project</span>
<span class="sd">            {&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 4, &#39;name&#39;: &#39;demo_project&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__project</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shotgun entity associated with this context.</span>

<span class="sd">        If the context is incomplete, it is possible that the property is None. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Light/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.entity</span>
<span class="sd">            {&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: 412, &#39;name&#39;: &#39;ABC&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__entity</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shotgun step associated with this context.</span>

<span class="sd">        If the context is incomplete, it is possible that the property is None. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Light/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.step</span>
<span class="sd">            {&#39;type&#39;: &#39;Step&#39;, &#39;id&#39;: 12, &#39;name&#39;: &#39;Light&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__step</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shotgun task associated with this context.</span>

<span class="sd">        If the context is incomplete, it is possible that the property is None. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/first_pass_lgt/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.task</span>
<span class="sd">            {&#39;type&#39;: &#39;Task&#39;, &#39;id&#39;: 212, &#39;name&#39;: &#39;first_pass_lgt&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__task</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A property which holds the user associated with this context.</span>
<span class="sd">        If the context is incomplete, it is possible that the property is None.</span>

<span class="sd">        The user property is special - either it represents a user value that was baked</span>
<span class="sd">        into a template path upon folder creation, or it represents the current user::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/dirk.gently/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.user</span>
<span class="sd">            {&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 23, &#39;name&#39;: &#39;Dirk Gently&#39;}</span>

<span class="sd">        :returns: A std shotgun link dictionary with keys id, type and name, or None if not defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE! get_shotgun_user returns more fields than just type, id and name</span>
        <span class="c1"># so make sure we get rid of those. We should make sure we return the data</span>
        <span class="c1"># in a consistent way, similar to all other entities. No more. No less.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">user</span> <span class="o">=</span> <span class="n">login</span><span class="o">.</span><span class="n">get_current_user</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__user</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> 
                               <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">),</span> 
                               <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">user</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__user</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">additional_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of entities that are required to provide a full context in non-standard configurations.</span>
<span class="sd">        The &quot;context_additional_entities&quot; core hook gives the context construction code hints about how</span>
<span class="sd">        this data should be populated.</span>

<span class="sd">        .. warning:: This is an old and advanced option and may be deprecated in the future. We strongly</span>
<span class="sd">                     recommend not using it.</span>

<span class="sd">        :returns: A list of std shotgun link dictionaries.</span>
<span class="sd">                  Will be an empty list in most cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__additional_entities</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entity_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of paths on disk which correspond to the **entity** which this context represents.</span>
<span class="sd">        If no folders have been created for this context yet, the value of this property will be an empty list::</span>


<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_entity(&quot;Task&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; ctx.entity_locations</span>
<span class="sd">            [&#39;/studio.08/demo_project/sequences/AAA/ABC&#39;]</span>

<span class="sd">        :returns: A list of paths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">paths_from_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">paths</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shotgun_url</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shotgun detail page url that best represents this context. Depending on </span>
<span class="sd">        the context, this may be a task, a shot, an asset or a project. If the context is </span>
<span class="sd">        completely empty, the root url of the associated shotgun installation is returned.</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_entity(&quot;Task&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; ctx.shotgun_url</span>
<span class="sd">            &#39;https://mystudio.shotgunstudio.com/detail/Task/8&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># walk up task -&gt; entity -&gt; project -&gt; site</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/detail/</span><span class="si">%s</span><span class="s2">/</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">,</span> <span class="s2">&quot;Task&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>            
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/detail/</span><span class="si">%s</span><span class="s2">/</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>            

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/detail/</span><span class="si">%s</span><span class="s2">/</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">,</span> <span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>            
        
        <span class="c1"># fall back on just the site main url</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun_url</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesystem_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A property which holds a list of paths on disk which correspond to this context.</span>
<span class="sd">        If no folders have been created for this context yet, the value of this property will be an empty list::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_entity(&quot;Task&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; ctx.filesystem_locations</span>
<span class="sd">            [&#39;/studio.08/demo_project/sequences/AAA/ABC/light/initial_pass&#39;]</span>

<span class="sd">        :returns: A list of paths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># first handle special cases: empty context</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="c1"># first handle special cases: project context</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">paths_from_entity</span><span class="p">(</span><span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
            
        <span class="c1"># at this stage we know that the context contains an entity</span>
        <span class="c1"># start off with all the paths matching this entity and then cull it down </span>
        <span class="c1"># based on constraints.</span>
        <span class="n">entity_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">paths_from_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
                
        <span class="c1"># for each of these paths, get the context and compare it against our context</span>
        <span class="c1"># todo: optimize this!</span>
        <span class="n">matching_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">entity_paths</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">context_from_path</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="c1"># the stuff we need to compare against are all the &quot;child&quot; levels</span>
            <span class="c1"># below entity: task and user</span>
            <span class="n">matching</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># no user data in either context</span>
                <span class="n">matching</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">ctx</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># both contexts have user data - is it matching?</span>
                <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]:</span>
                    <span class="n">matching</span> <span class="o">=</span> <span class="bp">True</span>
            
            <span class="k">if</span> <span class="n">matching</span><span class="p">:</span>
                <span class="c1"># ok so user looks good, now check task.</span>
                <span class="c1"># it is possible that with a context that comes from shotgun</span>
                <span class="c1"># there is a task populated which is not being used in the file system</span>
                <span class="c1"># so when we compare tasks, only if there are differing task ids, </span>
                <span class="c1"># we should treat it as a mismatch.</span>
                <span class="n">task_matching</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]:</span>
                        <span class="n">task_matching</span> <span class="o">=</span> <span class="bp">False</span>
                
                <span class="k">if</span> <span class="n">task_matching</span><span class="p">:</span>
                    <span class="c1"># both user and task is matching</span>
                    <span class="n">matching_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    
        <span class="k">return</span> <span class="n">matching_paths</span>
                    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sgtk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Toolkit API instance associated with this context</span>

<span class="sd">        :returns: :class:`Sgtk`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Legacy equivalent of :meth:`sgtk`</span>

<span class="sd">        :returns: :class:`Sgtk`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span>

    <span class="c1">################################################################################################</span>
    <span class="c1"># public methods</span>

<div class="viewcode-block" id="Context.as_template_fields"><a class="viewcode-back" href="../../core.html#sgtk.Context.as_template_fields">[docs]</a>    <span class="k">def</span> <span class="nf">as_template_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the context object as a dictionary of template fields.</span>

<span class="sd">        This is useful if you want to use a Context object as part of a call to</span>
<span class="sd">        the Sgtk API. In order for the system to pass suitable values, you need to</span>
<span class="sd">        pass the template you intend to use the data with as a parameter to this method.</span>
<span class="sd">        The values are derived from existing paths on disk, or in the case of keys with</span>
<span class="sd">        shotgun_entity_type and shotgun_entity_field settings, direct queries to the Shotgun</span>
<span class="sd">        server. The validate parameter can be used to ensure that the method returns all</span>
<span class="sd">        context fields required by the template and if it can&#39;t then a :class:`TankError` will be raised.</span>
<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>

<span class="sd">            # Create a template based on a path on disk. Because this path has been</span>
<span class="sd">            # generated through Toolkit&#39;s folder processing and there are corresponding</span>
<span class="sd">            # FilesystemLocation entities stored in Shotgun, the context can resolve</span>
<span class="sd">            # the path into a set of Shotgun entities.</span>
<span class="sd">            #</span>
<span class="sd">            # Note how the context object, once resolved, does not contain</span>
<span class="sd">            # any information about the sequence associated with the Shot.</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.project</span>
<span class="sd">            {&#39;type&#39;: &#39;Project&#39;, &#39;id&#39;: 4, &#39;name&#39;: &#39;demo_project&#39;}</span>
<span class="sd">            &gt;&gt;&gt; ctx.entity</span>
<span class="sd">            {&#39;type&#39;: &#39;Shot&#39;, &#39;id&#39;: 2, &#39;name&#39;: &#39;ABC&#39;}</span>
<span class="sd">            &gt;&gt;&gt; ctx.step</span>
<span class="sd">            {&#39;type&#39;: &#39;Step&#39;, &#39;id&#39;: 1, &#39;name&#39;: &#39;Light&#39;}</span>

<span class="sd">            # now if we have a template object that we want to turn into a path,</span>
<span class="sd">            # we can request that the context object attempts to resolve as many</span>
<span class="sd">            # fields as it can. These fields can then be plugged into the template</span>
<span class="sd">            # object to generate a path on disk</span>
<span class="sd">            &gt;&gt;&gt; templ = tk.templates[&quot;maya_shot_publish&quot;]</span>
<span class="sd">            &gt;&gt;&gt; templ</span>
<span class="sd">            &lt;Sgtk TemplatePath maya_shot_publish: sequences/{Sequence}/{Shot}/{Step}/publish/{name}.v{version}.ma&gt;</span>

<span class="sd">            &gt;&gt;&gt; fields = ctx.as_template_fields(templ)</span>
<span class="sd">            &gt;&gt;&gt; fields</span>
<span class="sd">            {&#39;Step&#39;: &#39;Lighting&#39;, &#39;Shot&#39;: &#39;ABC&#39;, &#39;Sequence&#39;: &#39;AAA&#39;}</span>

<span class="sd">            # the fields dictionary above contains all the &#39;high level&#39; data that is necessary to realise</span>
<span class="sd">            # the template path. An app or integration can now go ahead and populate the fields specific</span>
<span class="sd">            # for the app&#39;s business logic - in this case name and version - and resolve the fields dictionary</span>
<span class="sd">            # data into a path.</span>


<span class="sd">        :param template:    :class:`Template` for which the fields will be used.</span>
<span class="sd">        :param validate:    If True then the fields found will be checked to ensure that all expected fields for</span>
<span class="sd">                            the context were found.  If a field is missing then a :class:`TankError` will be raised</span>
<span class="sd">        :returns:           A dictionary of template files representing the context. Handy to pass to for example</span>
<span class="sd">                            :meth:`Template.apply_fields`.</span>
<span class="sd">        :raises:            :class:`TankError` if the fields can&#39;t be resolved for some reason or if &#39;validate&#39; is True</span>
<span class="sd">                            and any of the context fields for the template weren&#39;t found. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get all entities into a dictionary</span>
        <span class="n">entities</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="s2">&quot;Step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="s2">&quot;Task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="s2">&quot;HumanUser&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">:</span>
            <span class="n">entities</span><span class="p">[</span><span class="s2">&quot;Project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span>

        <span class="c1"># If there are any additional entities, use them as long as they don&#39;t</span>
        <span class="c1"># conflict with types we already have values for (Step, Task, Shot/Asset/etc)</span>
        <span class="k">for</span> <span class="n">add_entity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">add_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
                <span class="n">entities</span><span class="p">[</span><span class="n">add_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">add_entity</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Try to populate fields using paths caches for entity</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">TemplatePath</span><span class="p">):</span>

            <span class="c1"># first, sanity check that we actually have a path cache entry</span>
            <span class="c1"># this relates to ticket 22541 where it is possible to create </span>
            <span class="c1"># a context object purely from Shotgun without having it in the path cache</span>
            <span class="c1"># (using tk.context_from_entity(Task, 1234) for example)</span>
            <span class="c1">#</span>
            <span class="c1"># Such a context can result in erronous lookups in the later commands</span>
            <span class="c1"># since these make the assumption that the path cache contains the information</span>
            <span class="c1"># that is being saught after.</span>
            <span class="c1"># </span>
            <span class="c1"># therefore, if the context object contains an entity object and this entity is</span>
            <span class="c1"># not represented in the path cache, raise an exception.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entity_locations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># context has an entity associated but no path cache entries</span>
                <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot resolve template data for context &#39;</span><span class="si">%s</span><span class="s2">&#39; - this context &quot;</span>
                                <span class="s2">&quot;does not have any associated folders created on disk yet and &quot;</span>
                                <span class="s2">&quot;therefore no template data can be extracted. Please run the folder &quot;</span>
                                <span class="s2">&quot;creation for </span><span class="si">%s</span><span class="s2"> and try again!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">))</span>

            <span class="c1"># first look at which ENTITY paths are associated with this context object</span>
            <span class="c1"># and use these to extract the right fields for this template</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields_from_entity_paths</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

            <span class="c1"># filter the list of fields to just those that don&#39;t have a &#39;None&#39; value.</span>
            <span class="c1"># Note: A &#39;None&#39; value for a field indicates an ambiguity and was set in the </span>
            <span class="c1"># _fields_from_entity_paths method (!)</span>
            <span class="n">non_none_fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">fields</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">])</span>

            <span class="c1"># Determine additional field values by walking down the template tree</span>
            <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields_from_template_tree</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">non_none_fields</span><span class="p">,</span> <span class="n">entities</span><span class="p">))</span>

        <span class="c1"># get values for shotgun query keys in template</span>
        <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields_from_shotgun</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">entities</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">validate</span><span class="p">:</span>
            <span class="c1"># check that all context template fields were found and if not then raise a TankError</span>
            <span class="n">missing_fields</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key_name</span> <span class="ow">in</span> <span class="n">template</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key_name</span> <span class="ow">in</span> <span class="n">entities</span> <span class="ow">and</span> <span class="n">key_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                    <span class="c1"># we have a template key that should have been found but wasn&#39;t!</span>
                    <span class="n">missing_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">missing_fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot resolve template fields for context &#39;</span><span class="si">%s</span><span class="s2">&#39; - the following &quot;</span>
                                <span class="s2">&quot;keys could not be resolved: &#39;</span><span class="si">%s</span><span class="s2">&#39;.  Please run the folder creation &quot;</span>
                                <span class="s2">&quot;for &#39;</span><span class="si">%s</span><span class="s2">&#39; and try again!&quot;</span> 
                                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_fields</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shotgun_url</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">fields</span></div>

<div class="viewcode-block" id="Context.create_copy_for_user"><a class="viewcode-back" href="../../core.html#sgtk.Context.create_copy_for_user">[docs]</a>    <span class="k">def</span> <span class="nf">create_copy_for_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides the ability to create a copy of an existing Context for a specific user.</span>

<span class="sd">        This is useful if you need to determine a user specific version of a path, e.g.</span>
<span class="sd">        when copying files between different user sandboxes. Example::</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/dirk.gently/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx.user</span>
<span class="sd">            {&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 23, &#39;name&#39;: &#39;Dirk Gently&#39;}</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; copied_ctx = tk.create_copy_for_user({&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 7, &#39;name&#39;: &#39;John Snow&#39;})</span>
<span class="sd">            &gt;&gt;&gt; copied_ctx.user</span>
<span class="sd">            {&#39;type&#39;: &#39;HumanUser&#39;, &#39;id&#39;: 23, &#39;name&#39;: &#39;John Snow&#39;}</span>

<span class="sd">        :param user:  The Shotgun user entity dictionary that should be set on the copied context</span>
<span class="sd">        :returns: :class:`Context`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ctx_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ctx_copy</span><span class="o">.</span><span class="n">__user</span> <span class="o">=</span> <span class="n">user</span>
        <span class="k">return</span> <span class="n">ctx_copy</span></div>

    <span class="c1">################################################################################################</span>
    <span class="c1"># serialization</span>

<div class="viewcode-block" id="Context.serialize"><a class="viewcode-back" href="../../core.html#sgtk.Context.serialize">[docs]</a>    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_user_credentials</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Serializes the context into a string.</span>

<span class="sd">        Any Context object can be serialized to/deserialized from a string.</span>
<span class="sd">        This can be useful if you need to pass a Context between different processes.</span>
<span class="sd">        As an example, the ``tk-multi-launchapp`` uses this mechanism to pass the Context</span>
<span class="sd">        from the launch process (e.g. for example Shotgun Desktop) to the</span>
<span class="sd">        Application (e.g. Maya) being launched. Example:</span>

<span class="sd">            &gt;&gt;&gt; import sgtk</span>
<span class="sd">            &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio.08/demo_project&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ctx = tk.context_from_path(&quot;/studio.08/demo_project/sequences/AAA/ABC/Lighting/dirk.gently/work&quot;)</span>
<span class="sd">            &gt;&gt;&gt; context_str = ctx.serialize(ctx)</span>
<span class="sd">            &gt;&gt;&gt; new_ctx = sgtk.Context.deserialize(context_str)</span>

<span class="sd">        :param with_user_credentials: If ``True``, the currently authenticated user&#39;s credentials, as</span>
<span class="sd">            returned by :meth:`sgtk.get_authenticated_user`, will also be serialized with the context.</span>

<span class="sd">        .. note:: For example, credentials should be omitted (``with_user_credentials=False``) when</span>
<span class="sd">            serializing the context from a user&#39;s current session to send it to a render farm. By doing</span>
<span class="sd">            so, invoking :meth:`sgtk.Context.deserialize` on the render farm will only restore the</span>
<span class="sd">            context and not the authenticated user.</span>

<span class="sd">        :returns: String representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoids cyclic imports</span>
        <span class="kn">from</span> <span class="nn">.api</span> <span class="kn">import</span> <span class="n">get_authenticated_user</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">,</span>
            <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity</span><span class="p">,</span>
            <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">,</span>
            <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">,</span>
            <span class="s2">&quot;task&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">,</span>
            <span class="s2">&quot;additional_entities&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_entities</span><span class="p">,</span>
            <span class="s2">&quot;_pc_path&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tank</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">with_user_credentials</span><span class="p">:</span>
            <span class="c1"># If there is an authenticated user.</span>
            <span class="n">user</span> <span class="o">=</span> <span class="n">get_authenticated_user</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
                <span class="c1"># We should serialize it as well so that the next process knows who to</span>
                <span class="c1"># run as.</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_current_user&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">authentication</span><span class="o">.</span><span class="n">serialize_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Context.deserialize"><a class="viewcode-back" href="../../core.html#sgtk.Context.deserialize">[docs]</a>    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">context_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The inverse of :meth:`Context.serialize`.</span>

<span class="sd">        :param context_str: String representation of context, created with :meth:`Context.serialize`</span>

<span class="sd">        .. note:: If the context was serialized with the user credentials, the currently authenticated</span>
<span class="sd">            user will be updated with these credentials.</span>

<span class="sd">        :returns: :class:`Context`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># lazy load this to avoid cyclic dependencies</span>
        <span class="kn">from</span> <span class="nn">.api</span> <span class="kn">import</span> <span class="n">Tank</span><span class="p">,</span> <span class="n">set_authenticated_user</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">context_str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TankContextDeserializationError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

        <span class="c1"># first get the pipeline config path out of the dict</span>
        <span class="n">pipeline_config_path</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span>

        <span class="c1"># Authentication in Toolkit requires that credentials are passed from</span>
        <span class="c1"># one process to another so the currently authenticated user is carried</span>
        <span class="c1"># from one process to another. The current user needs to be part of the</span>
        <span class="c1"># context because multiple DCCs can run at the same time under different</span>
        <span class="c1"># users, e.g. launching Maya from the site as user A and Nuke from the tank</span>
        <span class="c1"># command as user B.</span>
        <span class="n">user_string</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_current_user&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">user_string</span><span class="p">:</span>
            <span class="c1"># Remove it from the data</span>
            <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_current_user&quot;</span><span class="p">]</span>
            <span class="c1"># and set the authenticated user user.</span>
            <span class="n">user</span> <span class="o">=</span> <span class="n">authentication</span><span class="o">.</span><span class="n">deserialize_user</span><span class="p">(</span><span class="n">user_string</span><span class="p">)</span>
            <span class="n">set_authenticated_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

        <span class="c1"># create a Sgtk API instance.</span>
        <span class="n">tk</span> <span class="o">=</span> <span class="n">Tank</span><span class="p">(</span><span class="n">pipeline_config_path</span><span class="p">)</span>

        <span class="c1"># add it to the constructor instance</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tk</span>

        <span class="c1"># and lastly make the obejct</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">)</span></div>

    <span class="c1">################################################################################################</span>
    <span class="c1"># private methods</span>

    <span class="k">def</span> <span class="nf">_fields_from_shotgun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">entities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Query Shotgun server for keys used by this template whose values come directly</span>
<span class="sd">        from Shotgun fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># for any sg query field</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">template</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            
            <span class="c1"># check each key to see if it has shotgun query information that we should resolve</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">:</span>
                <span class="c1"># this key is a shotgun value that needs fetching! </span>
                
                <span class="c1"># ensure that the context actually provides the desired entities</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Key &#39;</span><span class="si">%s</span><span class="s2">&#39; in template &#39;</span><span class="si">%s</span><span class="s2">&#39; could not be populated by &quot;</span>
                                    <span class="s2">&quot;context &#39;</span><span class="si">%s</span><span class="s2">&#39; because the context does not contain a &quot;</span>
                                    <span class="s2">&quot;shotgun entity of type &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span><span class="p">))</span>
                    
                <span class="n">entity</span> <span class="o">=</span> <span class="n">entities</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span><span class="p">]</span>
                
                <span class="c1"># check the context cache </span>
                <span class="n">cache_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_fields_cache</span><span class="p">:</span>
                    <span class="c1"># already have the value cached - no need to fetch from shotgun</span>
                    <span class="n">fields</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entity_fields_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>
                
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># get the value from shotgun</span>
                    <span class="n">filters</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]]]</span>
                    <span class="n">query_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">query_fields</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="c1"># no record with that id in shotgun!</span>
                        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Could not retrieve Shotgun data for key &#39;</span><span class="si">%s</span><span class="s2">&#39; in &quot;</span>
                                        <span class="s2">&quot;template &#39;</span><span class="si">%s</span><span class="s2">&#39;. No records in Shotgun are matching &quot;</span>
                                        <span class="s2">&quot;entity &#39;</span><span class="si">%s</span><span class="s2">&#39; (Which is part of the current &quot;</span>
                                        <span class="s2">&quot;context &#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>                        

                    <span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">)</span>

                    <span class="c1"># note! It is perfectly possible (and may be valid) to return None values from </span>
                    <span class="c1"># shotgun at this point. In these cases, a None field will be returned in the </span>
                    <span class="c1"># fields dictionary from as_template_fields, and this may be injected into</span>
                    <span class="c1"># a template with optional fields.</span>
    
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">processed_val</span> <span class="o">=</span> <span class="bp">None</span>
                    
                    <span class="k">else</span><span class="p">:</span>

                        <span class="c1"># now convert the shotgun value to a string.</span>
                        <span class="c1"># note! This means that there is no way currently to create an int key</span>
                        <span class="c1"># in a tank template which matches an int field in shotgun, since we are</span>
                        <span class="c1"># force converting everything into strings...</span>
                                 
                        <span class="n">processed_val</span> <span class="o">=</span> <span class="n">shotgun_entity</span><span class="o">.</span><span class="n">sg_entity_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">,</span>
                                                                           <span class="n">key</span><span class="o">.</span><span class="n">shotgun_entity_type</span><span class="p">,</span>
                                                                           <span class="n">entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">),</span>
                                                                           <span class="n">key</span><span class="o">.</span><span class="n">shotgun_field_name</span><span class="p">,</span> 
                                                                           <span class="n">value</span><span class="p">)</span>
                    
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">processed_val</span><span class="p">):</span>                    
                            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Template validation failed for value &#39;</span><span class="si">%s</span><span class="s2">&#39;. This &quot;</span>
                                            <span class="s2">&quot;value was retrieved from entity </span><span class="si">%s</span><span class="s2"> in Shotgun to &quot;</span>
                                            <span class="s2">&quot;represent key &#39;</span><span class="si">%s</span><span class="s2">&#39; in &quot;</span>
                                            <span class="s2">&quot;template &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">processed_val</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">template</span><span class="p">))</span>
                            
                    <span class="c1"># all good!</span>
                    <span class="c1"># populate dictionary and cache</span>
                    <span class="n">fields</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">processed_val</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_entity_fields_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">processed_val</span>


        <span class="k">return</span> <span class="n">fields</span>


    <span class="k">def</span> <span class="nf">_fields_from_entity_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines a template&#39;s key values based on context by walking up the context entities paths until</span>
<span class="sd">        matches for the template are found.</span>

<span class="sd">        :param template:    The template to find fields for</span>
<span class="sd">        :returns:           A dictionary of field name, value pairs for any fields found for the template</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">project_roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_data_roots</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="c1"># get all locations on disk for our context object from the path cache</span>
        <span class="n">path_cache_locations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_locations</span> 

        <span class="c1"># now loop over all those locations and check if one of the locations </span>
        <span class="c1"># are matching the template that is passed in. In that case, try to</span>
        <span class="c1"># extract the fields values.</span>
        <span class="k">for</span> <span class="n">cur_path</span> <span class="ow">in</span> <span class="n">path_cache_locations</span><span class="p">:</span>

            <span class="c1"># walk up path until we reach the project root and get values</span>
            <span class="k">while</span> <span class="n">cur_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">project_roots</span><span class="p">:</span>
                <span class="n">cur_fields</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">validate_and_get_fields</span><span class="p">(</span><span class="n">cur_path</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cur_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># If there are conflicts, there is ambiguity in the schema</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">cur_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                            <span class="c1"># Value is ambiguous for this key</span>
                            <span class="n">cur_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cur_fields</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cur_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">cur_path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fields</span>

    <span class="k">def</span> <span class="nf">_fields_from_template_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">known_fields</span><span class="p">,</span> <span class="n">context_entities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines values for a template&#39;s keys based on the context by walking down the template tree</span>
<span class="sd">        matching template keys with entity types.</span>

<span class="sd">        This method attempts to find as many fields as possible from the path cache but will try to ensure </span>
<span class="sd">        that incorrect fields are never returned, even if the path cache is not 100% clean (e.g. contains </span>
<span class="sd">        out-of-date paths for one or more of the entities in the context). </span>

<span class="sd">        :param template:            The template to find fields for</span>
<span class="sd">        :param known_fields:        Dictionary of fields that are already known for this template.  The</span>
<span class="sd">                                    logic in this method will ensure that any fields found match these.</span>
<span class="sd">        :param context_entities:    A dictionary of {entity_type:entity_dict} that contains all the entities </span>
<span class="sd">                                    belonging to this context.</span>
<span class="sd">        :returns:                   A dictionary of all fields found by this method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1 - Walk up the template tree and collect templates</span>
        <span class="c1">#</span>
        <span class="c1"># Use cached paths to find field values</span>
        <span class="c1"># these will be returned in top-down order:</span>
        <span class="c1"># [&lt;Sgtk TemplatePath sequences/{Sequence}&gt;, </span>
        <span class="c1">#  &lt;Sgtk TemplatePath sequences/{Sequence}/{Shot}&gt;, </span>
        <span class="c1">#  &lt;Sgtk TemplatePath sequences/{Sequence}/{Shot}/{Step}&gt;, </span>
        <span class="c1">#  &lt;Sgtk TemplatePath sequences/{Sequence}/{Shot}/{Step}/publish&gt;, </span>
        <span class="c1">#  &lt;Sgtk TemplatePath sequences/{Sequence}/{Shot}/{Step}/publish/maya&gt;, </span>
        <span class="c1">#  &lt;Sgtk TemplatePath maya_shot_publish: sequences/{Sequence}/{Shot}/{Step}/publish/maya/{name}.v{version}.ma&gt;]</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="n">_get_template_ancestors</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

        <span class="c1"># Step 2 - walk templates from the root down.</span>
        <span class="c1"># for each template, get all paths we have stored in the database and find any fields we can for it, making </span>
        <span class="c1"># sure that none of the found fields conflict with the list of entities provided to this method</span>
        <span class="c1">#</span>
        <span class="c1"># build up a list of fields as we go so that each level matches</span>
        <span class="c1"># at least the fields from all previous levels</span>
        <span class="n">found_fields</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># get a path cache handle</span>
        <span class="n">path_cache</span> <span class="o">=</span> <span class="n">PathCache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tk</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">templates</span><span class="p">:</span>
                <span class="c1"># iterate over all keys in the {key_name:key} dictionary for the template</span>
                <span class="c1"># looking for any that represent context entities (key name == entity type)</span>
                <span class="n">template_key_dict</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">keys</span>
                <span class="k">for</span> <span class="n">key_name</span> <span class="ow">in</span> <span class="n">template_key_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># Check to see if we already have a value for this key: </span>
                    <span class="k">if</span> <span class="n">key_name</span> <span class="ow">in</span> <span class="n">known_fields</span> <span class="ow">or</span> <span class="n">key_name</span> <span class="ow">in</span> <span class="n">found_fields</span><span class="p">:</span>
                        <span class="c1"># already have a value so skip</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">key_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">context_entities</span><span class="p">:</span>
                        <span class="c1"># key doesn&#39;t represent an entity so skip</span>
                        <span class="k">continue</span>

                    <span class="c1"># find fields for any paths associated with this entity by looking in the path cache:</span>
                    <span class="n">entity_fields</span> <span class="o">=</span> <span class="n">_values_from_path_cache</span><span class="p">(</span><span class="n">context_entities</span><span class="p">[</span><span class="n">key_name</span><span class="p">],</span> <span class="n">template</span><span class="p">,</span> <span class="n">path_cache</span><span class="p">,</span> 
                                                           <span class="n">required_fields</span><span class="o">=</span><span class="n">found_fields</span><span class="p">)</span>

                    <span class="c1"># entity_fields may contain additional fields that correspond to entities</span>
                    <span class="c1"># so we should be sure to validate these as well if we can.</span>
                    <span class="c1">#</span>
                    <span class="c1"># The following example illustrates where the code could previously return incorrect entity </span>
                    <span class="c1"># information from this method:</span>
                    <span class="c1">#</span>
                    <span class="c1"># With the following template:</span>
                    <span class="c1">#    /{Sequence}/{Shot}/{Step}</span>
                    <span class="c1">#</span>
                    <span class="c1"># And a path cache that contains:</span>
                    <span class="c1">#    Type     | Id  | Name     | Path</span>
                    <span class="c1">#    ----------------------------------------------------</span>
                    <span class="c1">#    Sequence | 001 | Seq_001  | /Seq_001</span>
                    <span class="c1">#    Shot     | 002 | Shot_A   | /Seq_001/Shot_A</span>
                    <span class="c1">#    Step     | 003 | Lighting | /Seq_001/Shot_A/Lighting</span>
                    <span class="c1">#    Step     | 003 | Lighting | /Seq_001/blah/Shot_B/Lighting   &lt;- this is out of date!</span>
                    <span class="c1">#    Shot     | 004 | Shot_B   | /Seq_001/blah/Shot_B            &lt;- this is out of date!</span>
                    <span class="c1">#</span>
                    <span class="c1"># (Note: the schema/templates have been changed since the entries for Shot_b were added)</span>
                    <span class="c1">#</span>
                    <span class="c1"># The sub-templates used to search for fields are:</span>
                    <span class="c1">#    /{Sequence}</span>
                    <span class="c1">#    /{Sequence}/{Shot}</span>
                    <span class="c1">#    /{Sequence}/{Shot}/{Step}</span>
                    <span class="c1">#</span>
                    <span class="c1"># And the entities passed into the method are:</span>
                    <span class="c1">#    Sequence:   Seq_001</span>
                    <span class="c1">#    Shot:       Shot_B</span>
                    <span class="c1">#    Step:       Lighting</span>
                    <span class="c1">#</span>
                    <span class="c1"># We are searching for fields for &#39;Shot_B&#39; that has a broken entry in the path cache so the fields </span>
                    <span class="c1"># returned for each level of the template will be:</span>
                    <span class="c1">#    /{Sequence}                 -&gt; {&quot;Sequence&quot;:&quot;Seq_001&quot;} &lt;- Correct</span>
                    <span class="c1">#    /{Sequence}/{Shot}          -&gt; {}                     &lt;- entry not found for Shot_B matching </span>
                    <span class="c1">#                                                             the template</span>
                    <span class="c1">#    /{Sequence}/{Shot}/{Step}   -&gt; {&quot;Sequence&quot;:&quot;Seq_001&quot;, &lt;- Correct</span>
                    <span class="c1">#                                    &quot;Shot&quot;:&quot;Shot_A&quot;,      &lt;- Wrong!</span>
                    <span class="c1">#                                    &quot;Step&quot;:&quot;Lighting&quot;}    &lt;- Correct</span>
                    <span class="c1">#</span>
                    <span class="c1"># In previous implementations, the final fields would incorrectly be returned as:</span>
                    <span class="c1">#</span>
                    <span class="c1">#     {&quot;Sequence&quot;:&quot;Seq_001&quot;,</span>
                    <span class="c1">#      &quot;Shot&quot;:&quot;Shot_A&quot;,</span>
                    <span class="c1">#      &quot;Step&quot;:&quot;Lighting&quot;}</span>
                    <span class="c1">#</span>
                    <span class="c1"># The wrong Shot (Shot_A) is returned and not caught because the code only tested that the Step</span>
                    <span class="c1"># entity matches and just assumes that the rest is correct - this isn&#39;t the case when there is</span>
                    <span class="c1"># a one-to-many relationship between entities!</span>
                    <span class="c1">#</span>
                    <span class="c1"># Therefore, we need to validate that we didn&#39;t find any entity fields that we should have found</span>
                    <span class="c1"># previously/higher up in the template definition.  If we did then the entries that were found </span>
                    <span class="c1"># may not be correct so we have to discard them!</span>
                    <span class="n">found_mismatching_field</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_value</span> <span class="ow">in</span> <span class="n">entity_fields</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">known_fields</span><span class="p">:</span>
                            <span class="c1"># We found a field we already knew about...</span>
                            <span class="k">if</span> <span class="n">field_value</span> <span class="o">!=</span> <span class="n">known_fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]:</span>
                                <span class="c1"># ...but it doesn&#39;t match!</span>
                                <span class="n">found_mismatching_field</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">elif</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">found_fields</span><span class="p">:</span>
                            <span class="c1"># We found a field we found before...</span>
                            <span class="k">if</span> <span class="n">field_value</span> <span class="o">!=</span> <span class="n">found_fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]:</span>
                                <span class="c1"># ...but it doesn&#39;t match!</span>
                                <span class="n">found_mismatching_field</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">elif</span> <span class="n">field_name</span> <span class="o">==</span> <span class="n">key_name</span><span class="p">:</span>
                            <span class="c1"># We found a field that matches the entity we were searching for so it must be valid!</span>
                            <span class="n">found_fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_value</span>
                        <span class="k">elif</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">context_entities</span><span class="p">:</span>
                            <span class="c1"># We found an entity type that we should have found before (in a previous/shorter </span>
                            <span class="c1"># template).  This means we can&#39;t trust any other fields that were found as they</span>
                            <span class="c1"># may belong to a completely different entity/path! </span>
                            <span class="n">found_mismatching_field</span> <span class="o">=</span> <span class="bp">True</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_mismatching_field</span><span class="p">:</span>
                        <span class="c1"># all fields are ok so we can add them all to the list of found fields :)</span>
                        <span class="n">found_fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">entity_fields</span><span class="p">)</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="n">path_cache</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">found_fields</span></div>


<span class="c1">################################################################################################</span>
<span class="c1"># factory methods for constructing new Context objects, primarily called from the Tank object</span>

<span class="k">def</span> <span class="nf">create_empty</span><span class="p">(</span><span class="n">tk</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs an empty context.</span>

<span class="sd">    :returns: a context object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="n">tk</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">from_entity</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a context from a shotgun entity.</span>

<span class="sd">    For more information, see :meth:`Sgtk.context_from_entity`.</span>

<span class="sd">    :param tk:           Sgtk API handle</span>
<span class="sd">    :param entity_type:  The shotgun entity type to produce a context for</span>
<span class="sd">    :param entity_id:    The shotgun entity id to produce a context for</span>
<span class="sd">    :returns: :class:`Context`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">entity_type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot create a context from an entity type &#39;None&#39;!&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">entity_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot create a context from an entity id set to &#39;None&#39;!&quot;</span><span class="p">)</span>
    
    <span class="c1"># prep our return data structure</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;tk&quot;</span><span class="p">:</span> <span class="n">tk</span><span class="p">,</span>
        <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;task&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;additional_entities&quot;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Task&quot;</span><span class="p">:</span>
        <span class="c1"># For tasks get data from shotgun query</span>
        <span class="n">task_context</span> <span class="o">=</span> <span class="n">_task_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">task_context</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">entity_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PublishedFile&quot;</span><span class="p">,</span> <span class="s2">&quot;TankPublishedFile&quot;</span><span class="p">]:</span>
        
        <span class="n">sg_entity</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> 
                                        <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">]],</span> 
                                        <span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">,</span> <span class="s2">&quot;entity&quot;</span><span class="p">,</span> <span class="s2">&quot;task&quot;</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">sg_entity</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Entity </span><span class="si">%s</span><span class="s2"> with id </span><span class="si">%s</span><span class="s2"> not found in Shotgun!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">sg_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">):</span>
            <span class="c1"># base the context on the task for the published file</span>
            <span class="k">return</span> <span class="n">from_entity</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="s2">&quot;Task&quot;</span><span class="p">,</span> <span class="n">sg_entity</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
        
        <span class="k">elif</span> <span class="n">sg_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity&quot;</span><span class="p">):</span>
            <span class="c1"># base the context on the entity that the published is linked with</span>
            <span class="k">return</span> <span class="n">from_entity</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">sg_entity</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="n">sg_entity</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
        
        <span class="k">elif</span> <span class="n">sg_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;project&quot;</span><span class="p">):</span>
            <span class="c1"># base the context on the project that the published is linked with</span>
            <span class="k">return</span> <span class="n">from_entity</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="n">sg_entity</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Get data from path cache</span>
        <span class="n">entity_context</span> <span class="o">=</span> <span class="n">_context_data_from_cache</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>
                    
        <span class="c1"># make sure this was actually found in the cache</span>
        <span class="c1"># fall back on a shotgun lookup if not found</span>
        <span class="k">if</span> <span class="n">entity_context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">entity_context</span> <span class="o">=</span> <span class="n">_entity_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>
        
        <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">entity_context</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
            <span class="c1"># no need to set entity to point at project in this case</span>
            <span class="c1"># that only produces double entries.</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="o">**</span><span class="n">context</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">from_entity_dictionary</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a context from a shotgun entity dictionary.</span>

<span class="sd">    For more information, see :meth:`Sgtk.context_from_entity_dictionary`.</span>

<span class="sd">    :param tk: :class:`Sgtk`</span>
<span class="sd">    :param entity_dictionary: The entity dictionary to create the context from</span>
<span class="sd">                              containing at least: {&quot;type&quot;:entity_type, &quot;id&quot;:entity_id}</span>
<span class="sd">    :returns: :class:`Context`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># perform validation of the entity dictionary:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entity_dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot create a context from an empty or invalid entity dictionary!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entity_dictionary</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot create a context without an entity type!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entity_dictionary</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Cannot create a context without an entity id!&quot;</span><span class="p">)</span>
    
    <span class="c1"># prep our context data structure</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;tk&quot;</span><span class="p">:</span> <span class="n">tk</span><span class="p">,</span>
        <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;task&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;additional_entities&quot;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">}</span>

    <span class="n">entity_type</span> <span class="o">=</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
    <span class="n">entity_id</span> <span class="o">=</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>

    <span class="c1"># try to determine the various entities from the entity dictionary:</span>
    <span class="n">project</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">entity</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">step</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">task</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
        <span class="c1"># find entities for a project context</span>
        <span class="n">project</span> <span class="o">=</span> <span class="n">entity_dictionary</span>
    <span class="k">elif</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Task&quot;</span><span class="p">:</span>
        <span class="c1"># find entities for a task context</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">entity_dictionary</span>
        <span class="k">if</span> <span class="s2">&quot;project&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">task</span> <span class="ow">or</span> <span class="s2">&quot;entity&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">task</span> <span class="ow">or</span> <span class="s2">&quot;step&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">project</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">entity_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PublishedFile&quot;</span><span class="p">,</span> <span class="s2">&quot;TankPublishedFile&quot;</span><span class="p">]:</span>
        <span class="c1"># special case handling for published files:</span>
        <span class="k">if</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">):</span>
            <span class="c1"># construct a task context</span>
            <span class="k">return</span> <span class="n">from_entity_dictionary</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity&quot;</span><span class="p">):</span>
            <span class="c1"># construct an entity context</span>
            <span class="k">return</span> <span class="n">from_entity_dictionary</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;project&quot;</span><span class="p">):</span>
            <span class="c1"># construct project context</span>
            <span class="k">return</span> <span class="n">from_entity_dictionary</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># fall back on from_entity:</span>
            <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># find entities for an entity context</span>
        <span class="n">entity</span> <span class="o">=</span> <span class="n">entity_dictionary</span>
        <span class="k">if</span> <span class="s2">&quot;project&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entity</span><span class="p">:</span>
            <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">project</span> <span class="o">=</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">fallback_to_ctx_from_entity</span><span class="p">:</span>
        <span class="c1"># clean up entities and populate context structure:</span>
        <span class="k">def</span> <span class="nf">_build_clean_entity</span><span class="p">(</span><span class="n">ent</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Ensure entity has id, type and name fields and build a clean</span>
<span class="sd">            entity dictionary containing just those fields to return, stripping</span>
<span class="sd">            out all other fields.</span>

<span class="sd">            :param ent: The entity dictionary to build a clean dictionary from</span>
<span class="sd">            :returns:   A clean entity dictionary containing just &#39;type&#39;, &#39;id&#39; </span>
<span class="sd">                        and &#39;name&#39; if all three exist in the input dictionary</span>
<span class="sd">                        or None if they don&#39;t.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># make sure we have id, type and name:</span>
            <span class="k">if</span> <span class="s2">&quot;id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ent</span> <span class="ow">or</span> <span class="s2">&quot;type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ent</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">ent_name</span> <span class="o">=</span> <span class="n">_get_entity_name</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ent_name</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="c1"># return a clean dictionary:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="n">ent</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span><span class="n">ent</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="n">ent_name</span><span class="p">}</span>
        
        <span class="k">if</span> <span class="n">project</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_clean_entity</span><span class="p">(</span><span class="n">project</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]:</span>
                <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="bp">True</span>
                
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fallback_to_ctx_from_entity</span> <span class="ow">and</span> <span class="n">entity</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_clean_entity</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]:</span>
                <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fallback_to_ctx_from_entity</span> <span class="ow">and</span> <span class="n">step</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_clean_entity</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]:</span>
                <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fallback_to_ctx_from_entity</span> <span class="ow">and</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_build_clean_entity</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]:</span>
                <span class="n">fallback_to_ctx_from_entity</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">fallback_to_ctx_from_entity</span><span class="p">:</span>
        <span class="c1"># entity dict doesn&#39;t contain enough information to build a </span>
        <span class="c1"># safe, valid context so fall back on &#39;from_entity&#39;:</span>
        <span class="k">return</span> <span class="n">from_entity</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
        <span class="c1"># one final check if we have a task:</span>
        <span class="n">additional_fields</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook</span><span class="p">(</span><span class="s2">&quot;context_additional_entities&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity_fields_on_task&quot;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">additional_fields</span><span class="p">:</span>
            <span class="c1"># unfortunately we have to fall back to an sg query to get the additional entities :(</span>
            <span class="n">task_context</span> <span class="o">=</span> <span class="n">_task_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">additional_fields</span><span class="p">)</span>
            <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">task_context</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="o">**</span><span class="n">context</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">from_path</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">previous_context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory method that constructs a context object from a path on disk.</span>

<span class="sd">    The algorithm will navigate upwards in the file system and collect</span>
<span class="sd">    as much tank metadata as possible to construct a Tank context.</span>

<span class="sd">    :param path: a file system path</span>
<span class="sd">    :param previous_context: A context object to use to try to automatically extend the generated</span>
<span class="sd">                             context if it is incomplete when extracted from the path. For example,</span>
<span class="sd">                             the Task may be carried across from the previous context if it is</span>
<span class="sd">                             suitable and if the task wasn&#39;t already expressed in the file system</span>
<span class="sd">                             path passed in via the path argument.</span>
<span class="sd">    :type previous_context: :class:`Context`</span>
<span class="sd">    :returns: :class:`Context`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># prep our return data structure</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;tk&quot;</span><span class="p">:</span> <span class="n">tk</span><span class="p">,</span>
        <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;task&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;additional_entities&quot;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">}</span>

    <span class="c1"># ask hook for extra entity types we should recognize and insert into the additional_entities list.</span>
    <span class="n">additional_types</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook</span><span class="p">(</span><span class="s2">&quot;context_additional_entities&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity_types_in_path&quot;</span><span class="p">,</span> <span class="p">[])</span>

    <span class="c1"># get a cache handle</span>
    <span class="n">path_cache</span> <span class="o">=</span> <span class="n">PathCache</span><span class="p">(</span><span class="n">tk</span><span class="p">)</span>

    <span class="c1"># gather all roots as lower case</span>
    <span class="n">project_roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_data_roots</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="c1"># first gather entities</span>
    <span class="n">entities</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">secondary_entities</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr_path</span> <span class="o">=</span> <span class="n">path</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">curr_entity</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_entity</span><span class="p">(</span><span class="n">curr_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr_entity</span><span class="p">:</span>
            <span class="c1"># Don&#39;t worry about entity types we&#39;ve already got in the context. In the future</span>
            <span class="c1"># we should look for entity ids that conflict in order to flag a degenerate schema.</span>
            <span class="n">entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_entity</span><span class="p">)</span>
        
        <span class="c1"># add secondary entities</span>
        <span class="n">secondary_entities</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_secondary_entities</span><span class="p">(</span><span class="n">curr_path</span><span class="p">)</span> <span class="p">)</span>

        <span class="k">if</span> <span class="n">curr_path</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">project_roots</span><span class="p">:</span>
            <span class="c1">#TODO this could fail with windows path variations</span>
            <span class="c1"># we have reached a root!</span>
            <span class="k">break</span>

        <span class="c1"># and continue with parent path</span>
        <span class="n">parent_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">curr_path</span><span class="p">,</span> <span class="s2">&quot;..&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">curr_path</span> <span class="o">==</span> <span class="n">parent_path</span><span class="p">:</span>
            <span class="c1"># We&#39;re at the disk root, probably a degenerate path</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_path</span> <span class="o">=</span> <span class="n">parent_path</span>

    <span class="n">path_cache</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># now populate the context</span>
    <span class="c1"># go from the root down, so that in the case there are a path with</span>
    <span class="c1"># multiple entities (like PROJECT/SEQUENCE/SHOT), the last entry</span>
    <span class="c1"># is the most relevant one, and will be assigned as the entity</span>
    <span class="k">for</span> <span class="n">curr_entity</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># handle the special context fields first</span>
        <span class="k">if</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Step&quot;</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Task&quot;</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;HumanUser&quot;</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">additional_types</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_entity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

    <span class="c1"># now that the context has been populated as much as possible using the</span>
    <span class="c1"># primary entities, fill in any blanks based on the secondary entities.</span>
    <span class="k">for</span> <span class="n">curr_entity</span> <span class="ow">in</span> <span class="n">secondary_entities</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># handle the special context fields first</span>
        <span class="k">if</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Step&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Task&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;HumanUser&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>
        
        <span class="k">elif</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">additional_types</span><span class="p">:</span>
            <span class="c1"># is this entity in the list already</span>
            <span class="k">if</span> <span class="n">curr_entity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">]:</span>            
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_entity</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

    <span class="c1"># see if we can populate it based on the previous context</span>
    <span class="k">if</span> <span class="n">previous_context</span> <span class="ow">and</span> \
       <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">entity</span> <span class="ow">and</span> \
       <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">additional_entities</span><span class="p">:</span>

        <span class="c1"># cool, everything is matching down to the step/task level.</span>
        <span class="c1"># if context is missing a step and a task, we try to auto populate it.</span>
        <span class="c1"># (note: weird edge that a context can have a task but no step)</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;step&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">step</span>

        <span class="c1"># now try to assign previous task but only if the step matches!</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous_context</span><span class="o">.</span><span class="n">task</span>

    <span class="c1"># ensure that we don&#39;t have a Project as the entity. Projects should only </span>
    <span class="c1"># appear on the projects level, despite being entities.</span>
    <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
        <span class="c1"># remove double entry!</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="o">**</span><span class="n">context</span><span class="p">)</span>


<span class="c1">################################################################################################</span>
<span class="c1"># serialization</span>

<span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Serializes the context into a string.</span>

<span class="sd">    .. deprecated:: v0.18.12</span>
<span class="sd">       Use :meth:`Context.serialize`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">context_str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The inverse of :meth:`serialize`.</span>

<span class="sd">    .. deprecated:: v0.18.12</span>
<span class="sd">       Use :meth:`Context.deserialize`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Context</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">context_str</span><span class="p">)</span>

<span class="c1">################################################################################################</span>
<span class="c1"># YAML representer/constructor</span>

<span class="k">def</span> <span class="nf">context_yaml_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom serializer.</span>
<span class="sd">    Creates yaml code for a context object.</span>

<span class="sd">    Legacy, kept for compatibility reasons, can probably be removed at this point.</span>

<span class="sd">    .. note:: Contrary to :meth:`sgtk.Context.serialize`, this method doesn&#39;t serialize the</span>
<span class="sd">        currently authenticated user.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># first get the stuff which represents all the Context() </span>
    <span class="c1"># constructor parameters</span>
    <span class="n">context_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="n">context</span><span class="o">.</span><span class="n">project</span><span class="p">,</span>
        <span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="n">context</span><span class="o">.</span><span class="n">entity</span><span class="p">,</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="n">context</span><span class="o">.</span><span class="n">user</span><span class="p">,</span>
        <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="n">context</span><span class="o">.</span><span class="n">step</span><span class="p">,</span>
        <span class="s2">&quot;task&quot;</span><span class="p">:</span> <span class="n">context</span><span class="o">.</span><span class="n">task</span><span class="p">,</span>
        <span class="s2">&quot;additional_entities&quot;</span><span class="p">:</span> <span class="n">context</span><span class="o">.</span><span class="n">additional_entities</span>
    <span class="p">}</span>
    
    <span class="c1"># now we also need to pass a TK instance to the constructor when we </span>
    <span class="c1"># are deserializing the object. For this purpose, pass a </span>
    <span class="c1"># pipeline config path as part of the dict</span>
    <span class="n">context_dict</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">tank</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_mapping</span><span class="p">(</span><span class="s1">u&#39;!TankContext&#39;</span><span class="p">,</span> <span class="n">context_dict</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">context_yaml_constructor</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom deserializer.</span>
<span class="sd">    Constructs a context object given the yaml data provided.</span>

<span class="sd">    Legacy, kept for compatibility reasons, can probably be removed at this point.</span>

<span class="sd">    .. note:: Contrary to :meth:`sgtk.Context.deserialize`, this method doesn&#39;t can&#39;t restore the</span>
<span class="sd">        currently authenticated user.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># lazy load this to avoid cyclic dependencies</span>
    <span class="kn">from</span> <span class="nn">.api</span> <span class="kn">import</span> <span class="n">Tank</span>
    
    <span class="c1"># get the dict from yaml</span>
    <span class="n">context_constructor_dict</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">construct_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="c1"># first get the pipeline config path out of the dict</span>
    <span class="n">pipeline_config_path</span> <span class="o">=</span> <span class="n">context_constructor_dict</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span> 
    <span class="k">del</span> <span class="n">context_constructor_dict</span><span class="p">[</span><span class="s2">&quot;_pc_path&quot;</span><span class="p">]</span>
    
    <span class="c1"># create a Sgtk API instance.</span>
    <span class="n">tk</span> <span class="o">=</span> <span class="n">Tank</span><span class="p">(</span><span class="n">pipeline_config_path</span><span class="p">)</span>

    <span class="c1"># add it to the constructor instance</span>
    <span class="n">context_constructor_dict</span><span class="p">[</span><span class="s2">&quot;tk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tk</span>

    <span class="c1"># and lastly make the obejct</span>
    <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="o">**</span><span class="n">context_constructor_dict</span><span class="p">)</span>

<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">Context</span><span class="p">,</span> <span class="n">context_yaml_representer</span><span class="p">)</span>
<span class="n">yaml</span><span class="o">.</span><span class="n">add_constructor</span><span class="p">(</span><span class="s1">u&#39;!TankContext&#39;</span><span class="p">,</span> <span class="n">context_yaml_constructor</span><span class="p">)</span>

<span class="c1">################################################################################################</span>
<span class="c1"># utility methods</span>

<span class="k">def</span> <span class="nf">_get_entity_type_sg_name_field</span><span class="p">(</span><span class="n">entity_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Shotgun name field to use for the specified entity type.  This</span>
<span class="sd">    is needed as not all entity types are consistent!</span>

<span class="sd">    :param entity_type:     The entity type to get the name field for</span>
<span class="sd">    :returns:               The name field for the specified entity type</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;HumanUser&quot;</span><span class="p">:</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> 
            <span class="s2">&quot;Task&quot;</span><span class="p">:</span><span class="s2">&quot;content&quot;</span><span class="p">,</span> 
            <span class="s2">&quot;Project&quot;</span><span class="p">:</span><span class="s2">&quot;name&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="s2">&quot;code&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_entity_name</span><span class="p">(</span><span class="n">entity_dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract the entity name from the specified entity dictionary if it can</span>
<span class="sd">    be found.  The entity dictionary must contain at least &#39;type&#39;</span>

<span class="sd">    :param entity_dictionary:   An entity dictionary to extract the name from</span>
<span class="sd">    :returns:                   The name of the entity if found in the entity</span>
<span class="sd">                                dictionary, otherwise None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name_field</span> <span class="o">=</span> <span class="n">_get_entity_type_sg_name_field</span><span class="p">(</span><span class="n">entity_dictionary</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
    <span class="n">entity_name</span> <span class="o">=</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name_field</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">entity_name</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Also check to see if entity contains &#39;name&#39;:</span>
        <span class="k">if</span> <span class="n">name_field</span> <span class="o">!=</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
            <span class="n">entity_name</span> <span class="o">=</span> <span class="n">entity_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">entity_name</span>

<span class="k">def</span> <span class="nf">_task_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">task_id</span><span class="p">,</span> <span class="n">additional_fields</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a context from a shotgun task.</span>
<span class="sd">    Because we are constructing the context from a task, we will get a context</span>
<span class="sd">    which has both a project, an entity a step and a task associated with it.</span>

<span class="sd">    Manne 9 April 2013: could we use the path cache primarily and fall back onto</span>
<span class="sd">                        a shotgun lookup? </span>

<span class="sd">    :param tk:                   An Sgtk API instance</span>
<span class="sd">    :param task_id:              The shotgun task id to produce a context for.</span>
<span class="sd">    :param additional_fields:    List of additional fields to query for additional entities.  If this is</span>
<span class="sd">                                &#39;None&#39; then the function will execute the hook to determine them. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Look up task&#39;s step and entity. This information should be static in practice, so we could</span>
    <span class="c1"># likely cache it in the future.</span>

    <span class="n">standard_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;content&quot;</span><span class="p">,</span> <span class="s2">&quot;entity&quot;</span><span class="p">,</span> <span class="s2">&quot;step&quot;</span><span class="p">,</span> <span class="s2">&quot;project&quot;</span><span class="p">]</span>
    <span class="c1"># theses keys map directly to linked entities, users will be handled separately</span>
    <span class="n">context_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">,</span> <span class="s2">&quot;entity&quot;</span><span class="p">,</span> <span class="s2">&quot;step&quot;</span><span class="p">,</span> <span class="s2">&quot;task&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">additional_fields</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># ask hook for extra Task entity fields we should query and insert into the additional_entities list.</span>
        <span class="n">additional_fields</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook</span><span class="p">(</span><span class="s2">&quot;context_additional_entities&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;entity_fields_on_task&quot;</span><span class="p">,</span> <span class="p">[])</span>

    <span class="n">task</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="s2">&quot;Task&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span><span class="s2">&quot;is&quot;</span><span class="p">,</span><span class="n">task_id</span><span class="p">]],</span> <span class="n">standard_fields</span> <span class="o">+</span> <span class="n">additional_fields</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">task</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Unable to locate Task with id </span><span class="si">%s</span><span class="s2"> in Shotgun&quot;</span> <span class="o">%</span> <span class="n">task_id</span><span class="p">)</span>

    <span class="c1"># add task so it can be processed with other shotgun entities</span>
    <span class="n">task</span><span class="p">[</span><span class="s2">&quot;task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Task&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">task_id</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;content&quot;</span><span class="p">]}</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">context_keys</span> <span class="o">+</span> <span class="n">additional_fields</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># gracefully skip stuff we don&#39;t have</span>
            <span class="c1"># for example tasks may not have a step</span>
            <span class="k">continue</span>

        <span class="c1"># be explicit about what we pull in - make no assumptions about what is</span>
        <span class="c1"># being returned from sg (the unit tests mocker doesn&#39;t return the same as the API)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">),</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">context_keys</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">additional_fields</span><span class="p">:</span>
            <span class="n">additional_entities</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">additional_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;additional_entities&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">additional_entities</span>

    <span class="k">return</span> <span class="n">context</span>


<span class="k">def</span> <span class="nf">_entity_from_sg</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the entity details for the specified entity type and id by querying Shotgun.</span>
<span class="sd">                        </span>
<span class="sd">    If entity_type is &#39;Project&#39; then this will return a single dictionary for the project.  For all</span>
<span class="sd">    other entity types, this will return dictionaries for both the entity and the project the entity </span>
<span class="sd">    exists under.</span>
<span class="sd">                        </span>
<span class="sd">    :param tk:          The sgtk api instance</span>
<span class="sd">    :param entity_type: The entity type to build a context for</span>
<span class="sd">    :param entity_id:   The entity id to build a context for</span>
<span class="sd">    :returns:           Dictionary containing either a project entity-dictionary or both</span>
<span class="sd">                        project and entity entity-dictionaries depending on the input entity type.</span>
<span class="sd">                        e.g. </span>
<span class="sd">                        {</span>
<span class="sd">                            &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;, &quot;id&quot;:123, &quot;name&quot;:&quot;My Project&quot;},</span>
<span class="sd">                            &quot;entity&quot;:{&quot;type&quot;:&quot;Shot&quot;, &quot;id&quot;:456, &quot;name&quot;:&quot;My Shot&quot;}</span>
<span class="sd">                        }</span>
<span class="sd">                            </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the sg name field for the specified entity type:</span>
    <span class="n">name_field</span> <span class="o">=</span> <span class="n">_get_entity_type_sg_name_field</span><span class="p">(</span><span class="n">entity_type</span><span class="p">)</span>
    
    <span class="c1"># get the entity data from Shotgun</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="p">[[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">]],</span> <span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">,</span> <span class="n">name_field</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Unable to locate </span><span class="si">%s</span><span class="s2"> with id </span><span class="si">%s</span><span class="s2"> in Shotgun&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">))</span>

    <span class="c1"># create context</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="n">entity_type</span> <span class="o">==</span> <span class="s2">&quot;Project&quot;</span><span class="p">:</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">entity_id</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name_field</span><span class="p">)</span> <span class="p">}</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">entity_type</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">entity_id</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name_field</span><span class="p">)</span> <span class="p">}</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;project&quot;</span><span class="p">)</span>     

    <span class="k">return</span> <span class="n">context</span>


<span class="k">def</span> <span class="nf">_context_data_from_cache</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds data to context based on path cache.</span>

<span class="sd">    :param tk: a Sgtk API instance</span>
<span class="sd">    :param entity_type: a Shotgun entity type</span>
<span class="sd">    :param entity_id: a Shotgun entity id</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Set entity info for input entity</span>
    <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">entity_type</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">entity_id</span><span class="p">}</span>

    <span class="c1"># Map entity types to context fields</span>
    <span class="n">types_fields</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Project&quot;</span><span class="p">:</span> <span class="s2">&quot;project&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Step&quot;</span><span class="p">:</span> <span class="s2">&quot;step&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Task&quot;</span><span class="p">:</span> <span class="s2">&quot;task&quot;</span><span class="p">}</span>

    <span class="c1"># Use the path cache to look up all paths linked to the entity and use that to extract</span>
    <span class="c1"># extra entities we should include in the context</span>
    <span class="n">path_cache</span> <span class="o">=</span> <span class="n">PathCache</span><span class="p">(</span><span class="n">tk</span><span class="p">)</span>

    <span class="c1"># Grab all project roots</span>
    <span class="n">project_roots</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_data_roots</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="c1"># Special case for project as we have the primary data path, which </span>
    <span class="c1"># always points at a project. We only check if the associated configuration</span>
    <span class="c1"># has any associated data roots, otherwise a primary config won&#39;t exist.</span>
    <span class="k">if</span> <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">has_associated_data_roots</span><span class="p">():</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_entity</span><span class="p">(</span><span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_primary_data_root</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">context</span><span class="p">[</span><span class="s2">&quot;project&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">paths</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_paths</span><span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">primary_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="c1"># now recurse upwards and look for entity types we haven&#39;t found yet</span>
        <span class="n">curr_path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="n">curr_entity</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_entity</span><span class="p">(</span><span class="n">curr_path</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">curr_entity</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># this is some sort of anomaly! the path returned by get_paths</span>
            <span class="c1"># does not resolve in get_entity. This can happen if the storage</span>
            <span class="c1"># mappings are not consistent or if there is not a 1 to 1 relationship</span>
            <span class="c1">#</span>
            <span class="c1"># This can also happen if there are extra slashes at the end of the path</span>
            <span class="c1"># in the local storage defs and in the pipeline_configuration.yml file.</span>
            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;The path &#39;</span><span class="si">%s</span><span class="s2">&#39; associated with </span><span class="si">%s</span><span class="s2"> id </span><span class="si">%s</span><span class="s2"> does not &quot;</span> 
                            <span class="s2">&quot;resolve correctly. This may be an indication of an issue &quot;</span>
                            <span class="s2">&quot;with the local storage setup. Please contact </span><span class="si">%s</span><span class="s2">.&quot;</span> 
                            <span class="o">%</span> <span class="p">(</span><span class="n">curr_path</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">SUPPORT_EMAIL</span><span class="p">))</span>

        <span class="c1"># grab the name for the context entity</span>
        <span class="k">if</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">entity_type</span> <span class="ow">and</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">entity_id</span><span class="p">:</span>
            <span class="n">context</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

        <span class="c1"># note - paths returned by get_paths are always prefixed with a</span>
        <span class="c1"># project root so there is no risk we end up with an infinite loop here..</span>
        <span class="k">while</span> <span class="n">curr_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">project_roots</span><span class="p">:</span>
            <span class="n">curr_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">curr_path</span><span class="p">,</span> <span class="s2">&quot;..&quot;</span><span class="p">))</span>
            <span class="n">curr_entity</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_entity</span><span class="p">(</span><span class="n">curr_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr_entity</span><span class="p">:</span>
                <span class="n">cur_type</span> <span class="o">=</span> <span class="n">curr_entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cur_type</span> <span class="ow">in</span> <span class="n">types_fields</span><span class="p">:</span>
                    <span class="n">field_name</span> <span class="o">=</span> <span class="n">types_fields</span><span class="p">[</span><span class="n">cur_type</span><span class="p">]</span>
                    <span class="n">context</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entity</span>

    <span class="n">path_cache</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">context</span>


<span class="k">def</span> <span class="nf">_values_from_path_cache</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">cur_template</span><span class="p">,</span> <span class="n">path_cache</span><span class="p">,</span> <span class="n">required_fields</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine values for template fields based on an entities cached paths.</span>
<span class="sd">                            </span>
<span class="sd">    :param entity:          The entity to search for fields for</span>
<span class="sd">    :param cur_template:    The template to use to search the path cache</span>
<span class="sd">    :path_cache:            An instance of the path_cache to search in</span>
<span class="sd">    :param required_fields: A list of fields that must exist in any matched path</span>
<span class="sd">    :return:                Dictionary of fields found by matching the template against all paths</span>
<span class="sd">                            found for the entity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># use the databsae to go from shotgun type/id --&gt; paths</span>
    <span class="n">entity_paths</span> <span class="o">=</span> <span class="n">path_cache</span><span class="o">.</span><span class="n">get_paths</span><span class="p">(</span><span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">],</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">primary_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># Mapping for field values found in conjunction with this entities paths</span>
    <span class="n">unique_fields</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># keys whose values should be removed from return values</span>
    <span class="n">remove_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">entity_paths</span><span class="p">:</span>
        
        <span class="c1"># validate path and get fields:</span>
        <span class="n">path_fields</span> <span class="o">=</span> <span class="n">cur_template</span><span class="o">.</span><span class="n">validate_and_get_fields</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">required_fields</span> <span class="o">=</span> <span class="n">required_fields</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path_fields</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Check values against those found for other paths</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">path_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">unique_fields</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">unique_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="c1"># value for this key isn&#39;t unique!</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]:</span>
                    <span class="c1"># Ambiguity for Entity key</span>
                    <span class="c1"># now it is possible that we have ambiguity here, but it is normally</span>
                    <span class="c1"># an edge case. For example imagine that an asset has paths</span>
                    <span class="c1"># /proj/hero_HIGH</span>
                    <span class="c1"># /proj/hero_LOW</span>
                    <span class="c1"># and we are mapping against template /%(Project)s/%(Asset)s</span>
                    <span class="c1"># both paths are valid matches, so we have ambiguous state for the entity</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Ambiguous data. Multiple paths cached for </span><span class="si">%s</span><span class="s2"> which match template </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entity</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_template</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># ambiguity for Static key</span>
                    <span class="n">unique_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">remove_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        
    <span class="c1"># we want to remove the None/ambiguous values so they don&#39;t interfere with other entities</span>
    <span class="k">for</span> <span class="n">remove_key</span> <span class="ow">in</span> <span class="n">remove_keys</span><span class="p">:</span>
        <span class="k">del</span><span class="p">(</span><span class="n">unique_fields</span><span class="p">[</span><span class="n">remove_key</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">unique_fields</span>


<span class="k">def</span> <span class="nf">_get_template_ancestors</span><span class="p">(</span><span class="n">template</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return templates branch of the template tree, ordered from first template</span>
<span class="sd">    below the project root down to and including the input template.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO this would probably be better as the Template&#39;s responsibility</span>
    <span class="n">templates</span> <span class="o">=</span> <span class="p">[</span><span class="n">template</span><span class="p">]</span>
    <span class="n">cur_template</span> <span class="o">=</span> <span class="n">template</span>
    <span class="k">while</span> <span class="n">cur_template</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_template</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">next_template</span> <span class="o">=</span> <span class="n">cur_template</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">templates</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">next_template</span><span class="p">)</span>
        <span class="n">cur_template</span> <span class="o">=</span> <span class="n">next_template</span>
    <span class="k">return</span> <span class="n">templates</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Autodesk.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'v0.18.22',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2114792-1', 'auto');
  ga('send', 'pageview');
</script>



</body>
</html>
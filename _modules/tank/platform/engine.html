



<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tank.platform.engine &mdash; tk-core v0.18.7 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="tk-core v0.18.7 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
    <a href='http://developer.shotgunsoftware.com'>
    
        <img style='width: 191px;
                height: 60px; 
                margin: 2px;
                border-radius: 0px; 
                padding: 0px;' 
            src='../../../_static/logo@2x.png'/>
    
    </a>
    

          
            <a href="../../../index.html" class="icon icon-home"> tk-core
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../bootstrap.html">Deploy and management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Foundation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../platform.html">Apps, Engines and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../descriptor.html">Descriptor API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authentication.html">Authentication</a></li>
</ul>

            
          
       
    <div style='margin-top: 50px;
                margin-left: 10px;
                margin-right: 10px;
                padding: 10px; 
                color: #b3b3b3; 
                font-size: 70%;
                border-radius: 3px;
                background-color: #444;
                line-height: 18px;
                '>    
    <style>
        a.custom_post_menu { display: inline; 
                             padding: 0px; 
                             text-decoration: underline; }
    </style>

    <b>tk-core</b> v0.18.7.<br>
    
        This documentation is part of the Shotgun Pipeline Toolkit.
    
    For more information, please visit
    <a class=custom_post_menu href='https://support.shotgunsoftware.com/home'>Shotgun Support</a>.
    The code associated with this documentation can be found 
    <a class=custom_post_menu href='https://github.com/shotgunsoftware/tk-core'>here</a>.

    </div>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">tk-core</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>tank.platform.engine</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tank.platform.engine</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2013 Shotgun Software Inc.</span>
<span class="c1"># </span>
<span class="c1"># CONFIDENTIAL AND PROPRIETARY</span>
<span class="c1"># </span>
<span class="c1"># This work is provided &quot;AS IS&quot; and subject to the Shotgun Pipeline Toolkit </span>
<span class="c1"># Source Code License included in this distribution package. See LICENSE.</span>
<span class="c1"># By accessing, using, copying or modifying this work you indicate your </span>
<span class="c1"># agreement to the Shotgun Pipeline Toolkit Source Code License. All rights </span>
<span class="c1"># not expressly granted therein are reserved by Shotgun Software Inc.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines the base class for all Tank Engines.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">with_statement</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">threading</span>
        
<span class="kn">from</span> <span class="nn">..util.loader</span> <span class="kn">import</span> <span class="n">load_plugin</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">hook</span>
<span class="kn">from</span> <span class="nn">..errors</span> <span class="kn">import</span> <span class="n">TankError</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">TankEngineInitError</span><span class="p">,</span> <span class="n">TankContextChangeNotSupportedError</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="kn">import</span> <span class="n">log_user_activity_metric</span><span class="p">,</span> <span class="n">log_user_attribute_metric</span>
<span class="kn">from</span> <span class="nn">..util.metrics</span> <span class="kn">import</span> <span class="n">MetricsDispatcher</span>
<span class="kn">from</span> <span class="nn">..log</span> <span class="kn">import</span> <span class="n">LogManager</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">application</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">validation</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">qt</span>
<span class="kn">from</span> <span class="nn">.bundle</span> <span class="kn">import</span> <span class="n">TankBundle</span>
<span class="kn">from</span> <span class="nn">.framework</span> <span class="kn">import</span> <span class="n">setup_frameworks</span>
<span class="kn">from</span> <span class="nn">.engine_logging</span> <span class="kn">import</span> <span class="n">ToolkitEngineHandler</span><span class="p">,</span> <span class="n">ToolkitEngineLegacyHandler</span>

<span class="c1"># std core level logger</span>
<span class="n">core_logger</span> <span class="o">=</span> <span class="n">LogManager</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="Engine"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine">[docs]</a><span class="k">class</span> <span class="nc">Engine</span><span class="p">(</span><span class="n">TankBundle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for an engine. When a new DCC integration is created, it should</span>
<span class="sd">    derive from this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_ASYNC_INVOKER</span><span class="p">,</span> <span class="n">_SYNC_INVOKER</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">engine_instance_name</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Engine instances are constructed by the toolkit launch process</span>
<span class="sd">        and various factory methods such as :meth:`start_engine`.</span>

<span class="sd">        :param tk: :class:`~sgtk.Sgtk` instance</span>
<span class="sd">        :param context: A context object to define the context on disk where the engine is operating</span>
<span class="sd">        :type context: :class:`~sgtk.Context`</span>
<span class="sd">        :param engine_instance_name: The name of the engine as it has been defined in the environment.</span>
<span class="sd">        :param env: An Environment object to associate with this engine.</span>


<span class="sd">        .. tell sphinx to document certain protected methods</span>
<span class="sd">        .. automethod:: _initialize_dark_look_and_feel</span>
<span class="sd">        .. automethod:: _define_qt_base</span>
<span class="sd">        .. automethod:: _create_dialog</span>
<span class="sd">        .. automethod:: _create_widget</span>
<span class="sd">        .. automethod:: _get_dialog_parent</span>
<span class="sd">        .. automethod:: _create_dialog_with_widget</span>
<span class="sd">        .. automethod:: _get_dialog_parent</span>
<span class="sd">        .. automethod:: _on_dialog_closed</span>
<span class="sd">        .. automethod:: _emit_log_message</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__engine_instance_name</span> <span class="o">=</span> <span class="n">engine_instance_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__applications</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__application_pool</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__shared_frameworks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__command_pool</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__panels</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__qt_widget_trash</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__created_qt_dialogs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__qt_debug_info</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__commands_that_need_prefixing</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__global_progress_widget</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics_dispatcher</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># Initialize these early on so that methods implemented in the derived class and trying</span>
        <span class="c1"># to access the invoker don&#39;t trip on undefined variables.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invoker</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_async_invoker</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># get the engine settings</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">get_engine_settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__engine_instance_name</span><span class="p">)</span>
        
        <span class="c1"># get the descriptor representing the engine        </span>
        <span class="n">descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">get_engine_descriptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__engine_instance_name</span><span class="p">)</span>        

        <span class="c1"># create logger for this engine.</span>
        <span class="c1"># log will be parented in a sgtk.env.environment_name.engine_instance_name hierarchy</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">LogManager</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="s2">&quot;env.</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">engine_instance_name</span><span class="p">))</span>

        <span class="c1"># init base class</span>
        <span class="n">TankBundle</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="c1"># create a log handler to handle log dispatch from self.log</span>
        <span class="c1"># (and the rest of the sgtk logging ) to the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__log_handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialize_logging</span><span class="p">()</span>

        <span class="c1"># check general debug log setting and if this flag is turned on,</span>
        <span class="c1"># adjust the global setting</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_setting</span><span class="p">(</span><span class="s2">&quot;debug_logging&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">global_debug</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Engine config flag &#39;debug_logging&#39; detected, turning on debug output.&quot;</span><span class="p">)</span>

        <span class="c1"># check that the context contains all the info that the app needs</span>
        <span class="n">validation</span><span class="o">.</span><span class="n">validate_context</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
        
        <span class="c1"># make sure the current operating system platform is supported</span>
        <span class="n">validation</span><span class="o">.</span><span class="n">validate_platform</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span>

        <span class="c1"># Get the settings for the engine and then validate them</span>
        <span class="n">engine_schema</span> <span class="o">=</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">configuration_schema</span>
        <span class="n">validation</span><span class="o">.</span><span class="n">validate_settings</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__engine_instance_name</span><span class="p">,</span>
            <span class="n">tk</span><span class="p">,</span>
            <span class="n">context</span><span class="p">,</span>
            <span class="n">engine_schema</span><span class="p">,</span>
            <span class="n">settings</span>
        <span class="p">)</span>
        
        <span class="c1"># set up any frameworks defined</span>
        <span class="n">setup_frameworks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">)</span>
        
        <span class="c1"># run the engine init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Engine init: Instantiating </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Engine init: Current Context: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">context</span><span class="p">)</span>

        <span class="c1"># now if a folder named python is defined in the engine, add it to the pythonpath</span>
        <span class="n">my_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__module__</span><span class="p">]</span><span class="o">.</span><span class="n">__file__</span><span class="p">)</span>
        <span class="n">python_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">my_path</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">BUNDLE_PYTHON_FOLDER</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">python_path</span><span class="p">):</span>
            <span class="c1"># Only append if __init__.py doesn&#39;t exist. If it does then we</span>
            <span class="c1"># should use the special tank import instead.</span>
            <span class="n">init_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">python_path</span><span class="p">,</span> <span class="s2">&quot;__init__.py&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">init_path</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Appending to PYTHONPATH: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">python_path</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">python_path</span><span class="p">)</span>


        <span class="c1"># Note, &#39;init_engine()&#39; is now deprecated and all derived initialisation should be</span>
        <span class="c1"># done in either &#39;pre_app_init()&#39; or &#39;post_app_init()&#39;.  &#39;init_engine()&#39; is left</span>
        <span class="c1"># in here to provide backwards compatibility with any legacy code. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_engine</span><span class="p">()</span>

        <span class="c1"># try to pull in QT classes and assign to tank.platform.qt.XYZ</span>
        <span class="n">base_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_define_qt_base</span><span class="p">()</span>
        <span class="n">qt</span><span class="o">.</span><span class="n">QtCore</span> <span class="o">=</span> <span class="n">base_def</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;qt_core&quot;</span><span class="p">)</span>
        <span class="n">qt</span><span class="o">.</span><span class="n">QtGui</span> <span class="o">=</span> <span class="n">base_def</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;qt_gui&quot;</span><span class="p">)</span>
        <span class="n">qt</span><span class="o">.</span><span class="n">TankDialogBase</span> <span class="o">=</span> <span class="n">base_def</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dialog_base&quot;</span><span class="p">)</span>

        <span class="c1"># Update the authentication module to use the engine&#39;s Qt.</span>
        <span class="c1"># @todo: can this import be untangled? Code references internal part of the auth module</span>
        <span class="kn">from</span> <span class="nn">..authentication.ui</span> <span class="kn">import</span> <span class="n">qt_abstraction</span>
        <span class="n">qt_abstraction</span><span class="o">.</span><span class="n">QtCore</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QtCore</span>
        <span class="n">qt_abstraction</span><span class="o">.</span><span class="n">QtGui</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QtGui</span>
        
        <span class="c1"># create invoker to allow execution of functions on the</span>
        <span class="c1"># main thread:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invoker</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_invoker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__create_invokers</span><span class="p">()</span>
        
        <span class="c1"># run any init that needs to be done before the apps are loaded:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_app_init</span><span class="p">()</span>
        
        <span class="c1"># now load all apps and their settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__load_apps</span><span class="p">()</span>
        
        <span class="c1"># execute the post engine init for all apps</span>
        <span class="c1"># note that this is executed before the post_app_init</span>
        <span class="c1"># in the engine - this is because typically the post app</span>
        <span class="c1"># init in the engine will contain code which captures the</span>
        <span class="c1"># state of the apps - for example creates a menu, so at that </span>
        <span class="c1"># point we want to try and have all app initialization complete.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__run_post_engine_inits</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">constants</span><span class="o">.</span><span class="n">SHELL_ENGINE_NAME</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">SHOTGUN_ENGINE_NAME</span><span class="p">]</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_018_logging_support</span><span class="p">():</span>

            <span class="c1"># if engine supports new logging implementation,</span>
            <span class="c1">#</span>
            <span class="c1"># we cannot add the &#39;toggle debug logging&#39; for</span>
            <span class="c1"># an engine that has the old logging implementation</span>
            <span class="c1"># because that typically contains overrides in log_debug</span>
            <span class="c1"># which effectively renders the command below useless</span>

            <span class="c1"># note that we omit this action in the special built-in</span>
            <span class="c1"># engines tk-shell and tk-shotgun</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">register_command</span><span class="p">(</span>
                <span class="s2">&quot;Toggle Debug Logging&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__toggle_debug_logging</span><span class="p">,</span>
                <span class="p">{</span>
                    <span class="s2">&quot;short_name&quot;</span><span class="p">:</span> <span class="s2">&quot;toggle_debug&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;icon&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_platform_resource_file</span><span class="p">(</span><span class="s2">&quot;book_256.png&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Toggles toolkit debug logging on and off. &quot;</span>
                                    <span class="s2">&quot;This affects all debug logging, including log &quot;</span>
                                    <span class="s2">&quot;files that are being written to disk.&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;context_menu&quot;</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="c1"># add a &#39;open log folder&#39; command to the engine&#39;s context menu</span>
        <span class="c1"># note: we make an exception for the shotgun engine which is a</span>
        <span class="c1"># special case.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">constants</span><span class="o">.</span><span class="n">SHOTGUN_ENGINE_NAME</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">register_command</span><span class="p">(</span>
                <span class="s2">&quot;Open Log Folder&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__open_log_folder</span><span class="p">,</span>
                <span class="p">{</span>
                    <span class="s2">&quot;short_name&quot;</span><span class="p">:</span> <span class="s2">&quot;open_log_folder&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;icon&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_platform_resource_file</span><span class="p">(</span><span class="s2">&quot;folder_256.png&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Opens the folder where log files are being stored.&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;context_menu&quot;</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="c1"># Useful dev helpers: If there is one or more dev descriptors in the</span>
        <span class="c1"># loaded environment, add a reload button to the menu!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__register_reload_command</span><span class="p">()</span>
        
        <span class="c1"># now run the post app init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_app_init</span><span class="p">()</span>
        
        <span class="c1"># emit an engine started event</span>
        <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">TANK_ENGINE_INIT_HOOK_NAME</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Init complete: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_metric</span><span class="p">(</span><span class="s2">&quot;Init&quot;</span><span class="p">)</span>

        <span class="c1"># log the core and engine versions being used by the current user</span>
        <span class="n">log_user_attribute_metric</span><span class="p">(</span><span class="s2">&quot;tk-core version&quot;</span><span class="p">,</span> <span class="n">tk</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
        <span class="n">log_user_attribute_metric</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> version&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,),</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>

        <span class="c1"># if the engine supports logging metrics, begin dispatching logged metrics</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics_dispatch_allowed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metrics_dispatcher</span> <span class="o">=</span> <span class="n">MetricsDispatcher</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Starting metrics dispatcher...&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metrics_dispatcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Metrics dispatcher started.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Sgtk Engine 0x</span><span class="si">%08x</span><span class="s2">: </span><span class="si">%s</span><span class="s2">, env: </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>  
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1">##########################################################################################</span>
    <span class="c1"># properties used by internal classes, not part of the public interface</span>

    <span class="k">def</span> <span class="nf">get_env</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the environment object associated with this engine.</span>
<span class="sd">        This is a private method which is internal to tank and should</span>
<span class="sd">        not be used by external code. This method signature may change at any point</span>
<span class="sd">        and the object returned may also change. Do not use outside of the core api.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span>

    <span class="k">def</span> <span class="nf">__toggle_debug_logging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Toggles global debug logging on and off in the log manager.</span>
<span class="sd">        This will affect all logging across all of toolkit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># flip debug logging</span>
        <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">global_debug</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">global_debug</span>

    <span class="k">def</span> <span class="nf">__open_log_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Opens the file system folder where log files are being stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_info</span><span class="p">(</span><span class="s2">&quot;Log folder is located in &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">log_folder</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ui</span><span class="p">:</span>
            <span class="c1"># only import QT if we have a UI</span>
            <span class="kn">from</span> <span class="nn">.qt</span> <span class="kn">import</span> <span class="n">QtGui</span><span class="p">,</span> <span class="n">QtCore</span>
            <span class="n">url</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QUrl</span><span class="o">.</span><span class="n">fromLocalFile</span><span class="p">(</span>
                <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">log_folder</span>
            <span class="p">)</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QDesktopServices</span><span class="o">.</span><span class="n">openUrl</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">status</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;Failed to open folder!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__is_method_subclassed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper that determines if the given method name</span>
<span class="sd">        has been subclassed in the currently running</span>
<span class="sd">        instance of the class or not.</span>

<span class="sd">        :param method_name: Name of engine method to check, e.g. &#39;log_debug&#39;.</span>
<span class="sd">        :return: True if subclassed, false if not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># grab active method and baseclass method</span>
        <span class="n">running_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
        <span class="n">base_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">Engine</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>

        <span class="c1"># now determine if the runtime implementation</span>
        <span class="c1"># is the base class implementation or not</span>
        <span class="n">subclassed</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
            <span class="c1"># older pythons use im_func rather than __func__</span>
            <span class="k">if</span> <span class="n">running_method</span><span class="o">.</span><span class="n">im_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">base_method</span><span class="o">.</span><span class="n">im_func</span><span class="p">:</span>
                <span class="n">subclassed</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pyton 2.6 and above use __func__</span>
            <span class="k">if</span> <span class="n">running_method</span><span class="o">.</span><span class="n">__func__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">base_method</span><span class="o">.</span><span class="n">__func__</span><span class="p">:</span>
                <span class="n">subclassed</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="n">subclassed</span>

    <span class="k">def</span> <span class="nf">__has_018_logging_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if the engine supports the new logging implementation.</span>

<span class="sd">        This is done by introspecting the _emit_log_message method.</span>
<span class="sd">        If this method is implemented for this engine, it is assumed</span>
<span class="sd">        that we are using the new logging system.</span>

<span class="sd">        :return: True if new logging is used, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_method_subclassed</span><span class="p">(</span><span class="s2">&quot;_emit_log_message&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__initialize_logging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a std python logging LogHandler</span>
<span class="sd">        that dispatches all log messages to the</span>
<span class="sd">        :meth:`Engine._emit_log_message()` method</span>
<span class="sd">        in a thread safe manner.</span>

<span class="sd">        For engines that do not yet implement :meth:`_emit_log_message`,</span>
<span class="sd">        a legacy log handler is used that dispatches messages</span>
<span class="sd">        to the legacy output methods log_xxx.</span>

<span class="sd">        :return: :class:`python.logging.LogHandler`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_018_logging_support</span><span class="p">():</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">initialize_custom_handler</span><span class="p">(</span>
                <span class="n">ToolkitEngineHandler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># make it easy for engines to implement a consistent log format</span>
            <span class="c1"># by equipping the handler with a standard formatter:</span>
            <span class="c1"># [DEBUG tk-maya] message message</span>
            <span class="c1">#</span>
            <span class="c1"># engines subclassing log output can call</span>
            <span class="c1"># handler.format to access this formatter for</span>
            <span class="c1"># a consistent output implementation</span>
            <span class="c1"># (see _emit_log_message for details)</span>
            <span class="c1">#</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span>
                <span class="s2">&quot;[</span><span class="si">%(levelname)s</span><span class="s2"> </span><span class="si">%(basename)s</span><span class="s2">] </span><span class="si">%(message)s</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># legacy engine that doesn&#39;t have _emit_log_message implemented</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">initialize_custom_handler</span><span class="p">(</span>
                <span class="n">ToolkitEngineLegacyHandler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># create a minimalistic format suitable for</span>
            <span class="c1"># existing output implementations of log_xxx</span>
            <span class="c1">#</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%(basename)s</span><span class="s2">: </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">handler</span>

    <span class="k">def</span> <span class="nf">__show_busy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">details</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Payload for the show_busy method.</span>

<span class="sd">        For details, see the main show_busy documentation.</span>
<span class="sd">        </span>
<span class="sd">        :param title: Short descriptive title of what is happening</span>
<span class="sd">        :param details: Detailed message describing what is going on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ui</span><span class="p">:</span>
            <span class="c1"># we cannot import QT until here as non-ui engines don&#39;t have QT defined.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">.qt.busy_dialog</span> <span class="kn">import</span> <span class="n">BusyDialog</span> 
                <span class="kn">from</span> <span class="nn">.qt</span> <span class="kn">import</span> <span class="n">QtGui</span><span class="p">,</span> <span class="n">QtCore</span>
                
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># QT import failed. This may be because someone has upgraded the core</span>
                <span class="c1"># to the latest but are still running a earlier version of the </span>
                <span class="c1"># Shotgun or Shell engine where the self.has_ui method is not</span>
                <span class="c1"># correctly implemented. In that case, absorb the error and  </span>
                <span class="c1"># emit a log message</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_info</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">] </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">details</span><span class="p">))</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># our qt import worked!</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__global_progress_widget</span><span class="p">:</span>
                    
                    <span class="c1"># no window exists - create one!</span>
                    <span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__global_progress_widget</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_dialog_with_widget</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Toolkit is busy&quot;</span><span class="p">,</span> 
                                                                                              <span class="n">bundle</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> 
                                                                                              <span class="n">widget_class</span><span class="o">=</span><span class="n">BusyDialog</span><span class="p">)</span>
                    
                    <span class="c1"># make it a splashscreen that sits on top</span>
                    <span class="n">window</span><span class="o">.</span><span class="n">setWindowFlags</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">SplashScreen</span> <span class="o">|</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">WindowStaysOnTopHint</span><span class="p">)</span>
    
                    <span class="c1"># set the message before the window is raised to avoid briefly</span>
                    <span class="c1"># showing default values</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__global_progress_widget</span><span class="o">.</span><span class="n">set_contents</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">details</span><span class="p">)</span>
                    
                    <span class="c1"># kick it off        </span>
                    <span class="n">window</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
                <span class="k">else</span><span class="p">:</span>
                                            
                    <span class="c1"># just update the message for the existing window </span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__global_progress_widget</span><span class="o">.</span><span class="n">set_contents</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">details</span><span class="p">)</span>

                <span class="c1"># make sure events are properly processed and the window is updated</span>
                <span class="n">QtCore</span><span class="o">.</span><span class="n">QCoreApplication</span><span class="o">.</span><span class="n">processEvents</span><span class="p">()</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no UI support! Instead, just emit a log message</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_info</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">] </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">details</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="nf">__clear_busy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Payload for clear_busy method. </span>
<span class="sd">        For details, see the main clear_busy documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__global_progress_widget</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__global_progress_widget</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__global_progress_widget</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">log_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Log an engine metric.</span>

<span class="sd">        :param action: Action string to log, e.g. &#39;Init&#39;</span>

<span class="sd">        Logs a user activity metric as performed within an engine. This is</span>
<span class="sd">        a convenience method that auto-populates the module portion of</span>
<span class="sd">        ``tank.util.log_user_activity_metric()``</span>

<span class="sd">        Internal Use Only - We provide no guarantees that this method</span>
<span class="sd">        will be backwards compatible.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># the action contains the engine and app name, e.g.</span>
        <span class="c1"># module: tk-maya</span>
        <span class="c1"># action: tk-maya - Init</span>
        <span class="n">full_action</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
        <span class="n">log_user_activity_metric</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">full_action</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">log_user_attribute_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience class. Logs a user attribute metric.</span>

<span class="sd">        :param attr_name: The name of the attribute to set for the user.</span>
<span class="sd">        :param attr_value: The value of the attribute to set for the user.</span>

<span class="sd">        This is a convenience wrapper around</span>
<span class="sd">        `tank.util.log_user_activity_metric()` that prevents engine subclasses</span>
<span class="sd">        from having to import from `tank.util`.</span>

<span class="sd">        Internal Use Only - We provide no guarantees that this method</span>
<span class="sd">        will be backwards compatible.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log_user_attribute_metric</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">attr_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_child_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a child logger for this engine.</span>

<span class="sd">        :param name: Name of child logger, can contain periods for nesting</span>
<span class="sd">        :return: :class:`logging.Logger` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_log_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">full_log_path</span><span class="p">)</span>

    <span class="c1">##########################################################################################</span>
    <span class="c1"># properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shotgun</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Shotgun API handle associated with the currently running</span>
<span class="sd">        environment. This method is a convenience method that calls out</span>
<span class="sd">        to :meth:`~sgtk.Tank.shotgun`.</span>

<span class="sd">        :returns: Shotgun API handle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pass on information to the user agent manager which bundle is returning</span>
        <span class="c1"># this sg handle. This information will be passed to the web server logs</span>
        <span class="c1"># in the shotgun data centre and makes it easy to track which app and engine versions</span>
        <span class="c1"># are being used by clients</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tank</span><span class="o">.</span><span class="n">shotgun</span><span class="o">.</span><span class="n">tk_user_agent_handler</span><span class="o">.</span><span class="n">set_current_engine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># looks like this sg instance for some reason does not have a</span>
            <span class="c1"># tk user agent handler associated.</span>
            <span class="k">pass</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tank</span><span class="o">.</span><span class="n">shotgun</span>        

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">environment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary with information about the environment.</span>
<span class="sd">         </span>
<span class="sd">        :returns: dictionary with keys ``name``,</span>
<span class="sd">                  ``description`` and ``disk_location``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">name</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">description</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;disk_location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">disk_location</span>
        
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">instance_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The instance name for this engine. The instance name</span>
<span class="sd">        is the entry that is defined in the environment file.</span>
<span class="sd">        </span>
<span class="sd">        :returns: instance name as string, e.g. ``tk-maya``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__engine_instance_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">apps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary of apps associated with this engine</span>
<span class="sd">        </span>
<span class="sd">        :returns: dictionary with keys being app name and values being app objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__applications</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">commands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary representing all the commands that have been registered</span>
<span class="sd">        by apps in this engine via :meth:`register_command`.</span>
<span class="sd">        Each dictionary item contains the following keys:</span>
<span class="sd">        </span>
<span class="sd">        - ``callback`` - function pointer to function to execute for this command</span>
<span class="sd">        - ``properties`` - dictionary with free form options - these are typically</span>
<span class="sd">          engine specific and driven by convention.</span>
<span class="sd">        </span>
<span class="sd">        :returns: commands dictionary, keyed by command name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">panels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Panels which have been registered with the engine via the :meth:`register_panel()`</span>
<span class="sd">        method. Returns a dictionary keyed by panel unique ids. Each value is a dictionary with keys</span>
<span class="sd">        ``callback`` and ``properties``.</span>

<span class="sd">        Returns all the panels which have been registered with the engine.</span>
<span class="sd">        </span>
<span class="sd">        :returns: A dictionary keyed by panel unique ids. Each value is a dictionary</span>
<span class="sd">                  with keys &#39;callback&#39; and &#39;properties&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__panels</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_ui</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates that the host application that the engine is connected to has a UI enabled.</span>
<span class="sd">        This always returns False for some engines (such as the shell engine) and may vary </span>
<span class="sd">        for some engines, depending if the host application for example is in batch mode or</span>
<span class="sd">        UI mode.</span>
<span class="sd">        </span>
<span class="sd">        :returns: boolean value indicating if a UI currently exists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># default implementation is to assume a UI exists</span>
        <span class="c1"># this is since most engines are supporting a graphical application</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">metrics_dispatch_allowed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates this engine will allow the metrics worker threads to forward</span>
<span class="sd">        the user metrics logged via core, this engine, or registered apps to</span>
<span class="sd">        SG.</span>

<span class="sd">        :returns: boolean value indicating that the engine allows user metrics</span>
<span class="sd">            to be forwarded to SG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">created_qt_dialogs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of dialog objects that have been created by the engine.</span>

<span class="sd">        :returns:   A list of TankQDialog objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__created_qt_dialogs</span>

    <span class="c1">##########################################################################################</span>
    <span class="c1"># init and destroy</span>
    
    <span class="k">def</span> <span class="nf">init_engine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Note: Now deprecated - Please use pre_app_init instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
<div class="viewcode-block" id="Engine.pre_app_init"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.pre_app_init">[docs]</a>    <span class="k">def</span> <span class="nf">pre_app_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up the engine into an operational state. Executed by the system and typically</span>
<span class="sd">        implemented by deriving classes. This method called before any apps are loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
    
<div class="viewcode-block" id="Engine.post_app_init"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.post_app_init">[docs]</a>    <span class="k">def</span> <span class="nf">post_app_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executed by the system and typically implemented by deriving classes.</span>
<span class="sd">        This method called after all apps have been loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
    
<div class="viewcode-block" id="Engine.destroy"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.destroy">[docs]</a>    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroy all apps, then call destroy_engine so subclasses can add their own tear down code.</span>

<span class="sd">        .. note:: This method should not be subclassed. Instead, implement :meth:`destroy_engine()`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">_CoreContextChangeHookGuard</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sgtk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__destroy_frameworks</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__destroy_apps</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Destroying </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">destroy_engine</span><span class="p">()</span>

            <span class="c1"># finally remove the current engine reference</span>
            <span class="n">set_current_engine</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

            <span class="c1"># now clear the hooks cache to make sure fresh hooks are loaded the</span>
            <span class="c1"># next time an engine is initialized</span>
            <span class="n">hook</span><span class="o">.</span><span class="n">clear_hooks_cache</span><span class="p">()</span>

            <span class="c1"># clean up the main thread invoker - it&#39;s a QObject so it&#39;s important we</span>
            <span class="c1"># explicitly set the value to None!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invoker</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_async_invoker</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c1"># halt metrics dispatching</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics_dispatcher</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics_dispatcher</span><span class="o">.</span><span class="n">dispatching</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Stopping metrics dispatcher.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_metrics_dispatcher</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Metrics dispatcher stopped.&quot;</span><span class="p">)</span>

        <span class="c1"># kill log handler</span>
        <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">root_logger</span><span class="o">.</span><span class="n">removeHandler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__log_handler</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__log_handler</span> <span class="o">=</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="Engine.destroy_engine"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.destroy_engine">[docs]</a>    <span class="k">def</span> <span class="nf">destroy_engine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when the engine should tear down itself and all its apps.</span>
<span class="sd">        Implemented by deriving classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Engine.change_context"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.change_context">[docs]</a>    <span class="k">def</span> <span class="nf">change_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when the engine is being asked to change contexts. This</span>
<span class="sd">        will only be allowed if the engine explicitly suppose on-the-fly</span>
<span class="sd">        context changes by way of its context_change_allowed property. Any</span>
<span class="sd">        apps that do not support context changing will be restarted instead.</span>
<span class="sd">        Custom behavior at the engine level should be handled by overriding</span>
<span class="sd">        one or both of pre_context_change and post_context_change methods.</span>

<span class="sd">        :param new_context:     The context to change to.</span>
<span class="sd">        :type new_context: :class:`~sgtk.Context`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure we&#39;re allowed to change context at the engine level.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">context_change_allowed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Engine </span><span class="si">%r</span><span class="s2"> does not allow context changes.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">TankContextChangeNotSupportedError</span><span class="p">()</span>

        <span class="c1"># Make sure that this engine is configured to run in the new context,</span>
        <span class="c1"># and that it&#39;s the EXACT same engine. This can be handled by comparing</span>
        <span class="c1"># the current engine&#39;s descriptor to the one coming from the new environment.</span>
        <span class="c1"># If this fails then it&#39;s more than just the engine not supporting the</span>
        <span class="c1"># context change, it&#39;s that the target context isn&#39;t configured properly.</span>
        <span class="c1"># As such, we&#39;ll let any exceptions (mostly TankEngineInitError) bubble</span>
        <span class="c1"># up since it&#39;s a critical error case.</span>
        <span class="p">(</span><span class="n">new_env</span><span class="p">,</span> <span class="n">engine_descriptor</span><span class="p">)</span> <span class="o">=</span> <span class="n">_get_env_and_descriptor_for_engine</span><span class="p">(</span>
            <span class="n">engine_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">instance_name</span><span class="p">,</span>
            <span class="n">tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tank</span><span class="p">,</span>
            <span class="n">context</span><span class="o">=</span><span class="n">new_context</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Make sure that the engine in the target context is the same as the current</span>
        <span class="c1"># engine. In the case of git or app_store descriptors, the equality check</span>
        <span class="c1"># is an &quot;is&quot; check to see if they&#39;re references to the same object due to the</span>
        <span class="c1"># fact that those descriptor types are singletons. For dev descriptors, the</span>
        <span class="c1"># check is going to compare the paths of the descriptors to see if they&#39;re</span>
        <span class="c1"># referencing the same data on disk, in which case they are equivalent.</span>
        <span class="k">if</span> <span class="n">engine_descriptor</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Engine </span><span class="si">%r</span><span class="s2"> does not match descriptors between </span><span class="si">%r</span><span class="s2"> and </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                <span class="n">new_context</span>
            <span class="p">))</span>
            <span class="k">raise</span> <span class="n">TankContextChangeNotSupportedError</span><span class="p">()</span>

        <span class="c1"># Run the pre_context_change method to allow for any engine-specific</span>
        <span class="c1"># prep work to happen.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span>
            <span class="s2">&quot;Executing pre_context_change for </span><span class="si">%r</span><span class="s2">, changing from </span><span class="si">%r</span><span class="s2"> to </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                <span class="n">new_context</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">with</span> <span class="n">_CoreContextChangeHookGuard</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sgtk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pre_context_change</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Execution of pre_context_change for engine </span><span class="si">%r</span><span class="s2"> is complete.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

            <span class="c1"># Check to see if all of our apps are capable of accepting</span>
            <span class="c1"># a context change. If one of them is not, then we remove it</span>
            <span class="c1"># from the persistent app pool, which will force it to be</span>
            <span class="c1"># rebuilt when apps are loaded later on.</span>
            <span class="n">non_compliant_app_paths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">install_path</span><span class="p">,</span> <span class="n">app_instances</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__application_pool</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">instance_name</span><span class="p">,</span> <span class="n">app</span> <span class="ow">in</span> <span class="n">app_instances</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span>
                        <span class="s2">&quot;Executing pre_context_change for </span><span class="si">%r</span><span class="s2">, changing from </span><span class="si">%r</span><span class="s2"> to </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="n">app</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                            <span class="n">new_context</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">app</span><span class="o">.</span><span class="n">pre_context_change</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Execution of pre_context_change for app </span><span class="si">%r</span><span class="s2"> is complete.&quot;</span> <span class="o">%</span> <span class="n">app</span><span class="p">)</span>

            <span class="c1"># Now that we&#39;re certain we can perform a context change,</span>
            <span class="c1"># we can tell the environment what the new context is, update</span>
            <span class="c1"># our own context property, and load the apps. The app load</span>
            <span class="c1"># will repopulate the __applications dict to contain the appropriate</span>
            <span class="c1"># apps for the new context, and will pull apps that have already</span>
            <span class="c1"># been loaded from the __application_pool, which is persistent.</span>
            <span class="n">old_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__env</span> <span class="o">=</span> <span class="n">new_env</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_context</span><span class="p">(</span><span class="n">new_context</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__load_apps</span><span class="p">(</span><span class="n">reuse_existing_apps</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">old_context</span><span class="o">=</span><span class="n">old_context</span><span class="p">)</span>

            <span class="c1"># Call the post_context_change method to allow for any engine</span>
            <span class="c1"># specific post-change logic to be run.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span>
                <span class="s2">&quot;Executing post_context_change for </span><span class="si">%r</span><span class="s2">, changing from </span><span class="si">%r</span><span class="s2"> to </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                    <span class="n">new_context</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Emit the core level event.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">post_context_change</span><span class="p">(</span><span class="n">old_context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Execution of post_context_change for engine </span><span class="si">%r</span><span class="s2"> is complete.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Last, now that we&#39;re otherwise done, we can run the</span>
        <span class="c1"># apps&#39; post_engine_init methods.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__run_post_engine_inits</span><span class="p">()</span></div>

    <span class="c1">##########################################################################################</span>
    <span class="c1"># public methods</span>

<div class="viewcode-block" id="Engine.show_busy"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.show_busy">[docs]</a>    <span class="k">def</span> <span class="nf">show_busy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">details</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Displays or updates a global &quot;busy window&quot; tied to this engine. The window</span>
<span class="sd">        is a splash screen type window, floats on top and contains details of what</span>
<span class="sd">        is currently being processed.</span>

<span class="sd">        This method pops up a splash screen with a message and the idea is that</span>
<span class="sd">        long running core processes can use this as a way to communicate their intent</span>
<span class="sd">        to the user and keep the user informed as slow processes are executed. If the engine</span>
<span class="sd">        has a UI present, this will be used to display the progress message. If the engine</span>
<span class="sd">        does not have UI support, a message will be logged. The UI always appears in the</span>
<span class="sd">        main thread for safety.</span>

<span class="sd">        Only one global progress window can exist per engine at a time, so if you want to</span>
<span class="sd">        push several updates one after the other, just keep calling this method.</span>

<span class="sd">        When you want to remove the window, call :meth:`clear_busy()`.</span>

<span class="sd">        Note! If you are calling this from the Core API you typically don&#39;t have</span>
<span class="sd">        access to the current engine object. In this case you can use the</span>
<span class="sd">        convenience method ``tank.platform.engine.show_global_busy()`` which will</span>
<span class="sd">        attempt to broadcast the request to the currently active engine.</span>

<span class="sd">        :params title: Short descriptive title of what is happening</span>
<span class="sd">        :params details: Detailed message describing what is going on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure that the UI is always shown in the main thread</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execute_in_main_thread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__show_busy</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">details</span><span class="p">)</span></div>

<div class="viewcode-block" id="Engine.clear_busy"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.clear_busy">[docs]</a>    <span class="k">def</span> <span class="nf">clear_busy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Closes any active busy window.</span>

<span class="sd">        For more details, see the :meth:`show_busy()` documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__global_progress_widget</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute_in_main_thread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__clear_busy</span><span class="p">)</span></div>


<div class="viewcode-block" id="Engine.register_command"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.register_command">[docs]</a>    <span class="k">def</span> <span class="nf">register_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a command with a name and a callback function.</span>

<span class="sd">        A *command* refers to an access point for some functionality.</span>
<span class="sd">        In most cases, commands will appear as items on a Shotgun dropdown</span>
<span class="sd">        menu, but it ultimately depends on the engine - in the Shell engine,</span>
<span class="sd">        commands are instead represented as a text base listing and in the</span>
<span class="sd">        Shotgun Desktop it is a scrollable list of larger icons.</span>

<span class="sd">        An arbitrary list of properties can be passed into the engine</span>
<span class="sd">        in the form of a properties dictionary. The interpretation of</span>
<span class="sd">        the properties dictionary is engine specific, but in general</span>
<span class="sd">        the following properties are supported:</span>

<span class="sd">        - ``short_name`` - A shorter name, typically intended for console use (e.g. &#39;import_cut&#39;)</span>

<span class="sd">        - ``icon`` - A path to a 256x256 png app icon. If not specified, the icon for the app will be used.</span>

<span class="sd">        - ``description`` - a one line description of the command, suitable for a tooltip.</span>
<span class="sd">          If no description is passed, the one provided in the app manifest will be used.</span>

<span class="sd">        - ``type`` - The type of command - hinting where it should appear. Options vary between</span>
<span class="sd">          engines and the following three are supported:</span>

<span class="sd">            - ``context_menu`` - Supported on all engines. Place item on</span>
<span class="sd">              the context menu (first item on the shotgun menu).</span>
<span class="sd">            - ``panel`` - This command is associated with a panel app if the target</span>
<span class="sd">              environment supports a special notion of panel related actions, place</span>
<span class="sd">              the command there. (supported by for example Nuke)</span>
<span class="sd">            - ``node`` - For applications that have a specific node menu (like Nuke),</span>
<span class="sd">              place the command there.</span>

<span class="sd">        Specifically for the Shotgun engine, the following parameters are supported:</span>

<span class="sd">        - ``title`` - Title to appear on shotgun action menu (e.g. &quot;Create Folders&quot;)</span>

<span class="sd">        - ``deny_permissions`` - List of permission groups to exclude this</span>
<span class="sd">          menu item for (e.g. ``[&quot;Artist&quot;]``)</span>

<span class="sd">        - ``deny_platforms`` - List of platforms for which not to show the menu</span>
<span class="sd">          (e.g. ``[&quot;windows&quot;, &quot;mac&quot;, &quot;linux&quot;]``). Please note that there are</span>
<span class="sd">          other ways to achieve this same result.</span>

<span class="sd">        - ``supports_multiple_selection`` - a special flag that allows multiple objects</span>
<span class="sd">          in Shotgun to be selected and operated on. An example showing how to write a</span>
<span class="sd">          multi select shotgun app is provided in a special branch in the sample starter</span>
<span class="sd">          app: https://github.com/shotgunsoftware/tk-multi-starterapp/tree/shotgun_multi_select</span>


<span class="sd">        Typical usage normally looks something like this -</span>
<span class="sd">        register_command is called from the :meth:`Application.init_app()` method of an app::</span>

<span class="sd">            self.engine.register_command(</span>
<span class="sd">                &quot;Work Area Info...&quot;,</span>
<span class="sd">                callback,</span>
<span class="sd">                {&quot;type&quot;: &quot;context_menu&quot;, &quot;short_name&quot;: &quot;work_area_info&quot;}</span>
<span class="sd">            )</span>

<span class="sd">        :param name: Name of the command. This will be the key when accessed via the</span>
<span class="sd">                     :meth:`commands` dictionary.</span>
<span class="sd">        :param callback: Callback to call upon command execution</span>
<span class="sd">        :param properties: Dictionary with command properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">properties</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">properties</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># uniqueness prefix, populated when there are several instances of the same app</span>
        <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;prefix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c1"># try to add an app key to the dict with the app requesting the command</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># track which apps this request came from</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;app&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span>
        
        <span class="c1"># add some defaults. If there isn&#39;t a description key, add it from the app&#39;s manifest</span>
        <span class="k">if</span> <span class="s2">&quot;description&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">properties</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span><span class="p">:</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span><span class="o">.</span><span class="n">description</span>
        
        <span class="k">if</span> <span class="s2">&quot;icon&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">properties</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span><span class="p">:</span>
            <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;icon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span><span class="o">.</span><span class="n">descriptor</span><span class="o">.</span><span class="n">icon_256</span>

        <span class="c1"># check for duplicates!</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span><span class="p">:</span>
            <span class="c1"># already something in the dict with this name</span>
            <span class="n">existing_item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">existing_item</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">):</span>
                <span class="c1"># we know the app for the existing item.</span>
                <span class="c1"># so prefix with app name</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">existing_item</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">instance_name</span>
                <span class="n">new_name_for_existing</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span><span class="p">[</span><span class="n">new_name_for_existing</span><span class="p">]</span> <span class="o">=</span> <span class="n">existing_item</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span><span class="p">[</span><span class="n">new_name_for_existing</span><span class="p">][</span><span class="s2">&quot;properties&quot;</span><span class="p">][</span><span class="s2">&quot;prefix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix</span> 
                <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__commands</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                <span class="c1"># add it to our list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__commands_that_need_prefixing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                      
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__commands_that_need_prefixing</span><span class="p">:</span>
            <span class="c1"># try to append a prefix if possible</span>
            <span class="k">if</span> <span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">):</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">instance_name</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="c1"># also add a prefix key in the properties dict</span>
                <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;prefix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix</span>

        <span class="c1"># now define command wrappers to capture metrics logging</span>
        <span class="c1"># on command execution. The toolkit callback system supports</span>
        <span class="c1"># two different callback styles:</span>
        <span class="c1">#</span>
        <span class="c1"># - A legacy type which is only used by Shotgun Apps which</span>
        <span class="c1">#   utilize multi select. These callbacks are always on the</span>
        <span class="c1">#   form callback(entity_type, entity_ids)</span>
        <span class="c1">#</span>
        <span class="c1"># - The standard type, which does not pass any arguments:</span>
        <span class="c1">#   callback()</span>
        <span class="c1">#</span>

        <span class="c1"># introspect the arg list to determine this and set a flag</span>
        <span class="c1"># to highlight this state. This is used by the tank_command</span>
        <span class="c1"># execution logic to correctly dispatch the callback during</span>
        <span class="c1"># runtime.</span>
        <span class="n">arg_spec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
        <span class="c1"># note - cannot use named tuple form because it is py2.6+</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="n">arg_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;entity_type&quot;</span> <span class="ow">in</span> <span class="n">arg_list</span> <span class="ow">and</span> <span class="s2">&quot;entity_ids&quot;</span> <span class="ow">in</span> <span class="n">arg_list</span><span class="p">:</span>
            <span class="c1"># add property flag</span>
            <span class="n">properties</span><span class="p">[</span><span class="n">constants</span><span class="o">.</span><span class="n">LEGACY_MULTI_SELECT_ACTION_FLAG</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># define a generic callback wrapper for metrics logging</span>
        <span class="k">def</span> <span class="nf">callback_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">):</span>
                <span class="c1"># track which app command is being launched</span>
                <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;app&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">log_metric</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="n">log_version</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c1"># run the actual payload callback</span>
            <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;callback&quot;</span><span class="p">:</span> <span class="n">callback_wrapper</span><span class="p">,</span>
            <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="n">properties</span><span class="p">,</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="Engine.register_panel"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.register_panel">[docs]</a>    <span class="k">def</span> <span class="nf">register_panel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">panel_name</span><span class="o">=</span><span class="s2">&quot;main&quot;</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to :meth:`register_command()`, but instead of registering a menu item in the form of a</span>
<span class="sd">        command, this method registers a UI panel. A register_panel call should</span>
<span class="sd">        be used in conjunction with a register_command call.</span>
<span class="sd">        </span>
<span class="sd">        Panels need to be registered if they should persist between DCC sessions (e.g. </span>
<span class="sd">        for example &#39;saved layouts&#39;).</span>
<span class="sd">        </span>
<span class="sd">        Just like with the :meth:`register_command` method, panel registration should be executed</span>
<span class="sd">        from within the init phase of the app. Once a panel has been registered, it is possible</span>
<span class="sd">        for the engine to correctly restore panel UIs at startup and profile switches. </span>
<span class="sd">        </span>
<span class="sd">        Not all engines support this feature, but in for example Nuke, a panel can be added to </span>
<span class="sd">        a saved layout. Apps wanting to be able to take advantage of the persistence given by</span>
<span class="sd">        these saved layouts will need to call register_panel as part of their init_app phase.</span>
<span class="sd">        </span>
<span class="sd">        In order to show or focus on a panel, use the :meth:`show_panel` method instead.</span>
<span class="sd">        </span>
<span class="sd">        :param callback: Callback to a factory method that creates the panel and returns a panel widget.</span>
<span class="sd">        :param panel_name: A string to distinguish this panel from other panels created by </span>
<span class="sd">                           the app. This will be used as part of the unique id for the panel.</span>
<span class="sd">        :param properties: Properties dictionary. Reserved for future use.</span>
<span class="sd">        :returns: A unique identifier that can be used to consistently identify the </span>
<span class="sd">                  panel across sessions. This identifier should be used to identify the panel</span>
<span class="sd">                  in all subsequent calls, e.g. for example :meth:`show_panel()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">properties</span> <span class="ow">or</span> <span class="p">{}</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># register_panel is called from outside of init_app</span>
            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;register_panel must be called from inside of the init_app() method!&quot;</span><span class="p">)</span>
        
        <span class="n">current_app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span>
        
        <span class="c1"># similar to register_command, track which app this request came from</span>
        <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;app&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_app</span> 
        
        <span class="c1"># now compose a unique id for this panel.</span>
        <span class="c1"># This is done based on the app instance name plus the given panel name.</span>
        <span class="c1"># By using the instance name rather than the app name, we support the</span>
        <span class="c1"># use case where more than one instance of an app exists within a</span>
        <span class="c1"># config.</span>
        <span class="n">panel_id</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">instance_name</span><span class="p">,</span> <span class="n">panel_name</span><span class="p">)</span>
        <span class="c1"># to ensure the string is safe to use in most engines,</span>
        <span class="c1"># sanitize to simple alpha-numeric form</span>
        <span class="n">panel_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;\W&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">panel_id</span><span class="p">)</span>
        <span class="n">panel_id</span> <span class="o">=</span> <span class="n">panel_id</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># add it to the list of registered panels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__panels</span><span class="p">[</span><span class="n">panel_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;callback&quot;</span><span class="p">:</span> <span class="n">callback</span><span class="p">,</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="n">properties</span><span class="p">}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Registered panel </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">panel_id</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">panel_id</span></div>
        
<div class="viewcode-block" id="Engine.execute_in_main_thread"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.execute_in_main_thread">[docs]</a>    <span class="k">def</span> <span class="nf">execute_in_main_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the specified function in the main thread when called from a non-main</span>
<span class="sd">        thread.  This will block the calling thread until the function returns. Note that this</span>
<span class="sd">        method can introduce a deadlock if the main thread is waiting for a background thread</span>
<span class="sd">        and the background thread is invoking this method. Since the main thread is waiting</span>
<span class="sd">        for the background thread to finish, Qt&#39;s event loop won&#39;t be able to process the request</span>
<span class="sd">        to execute in the main thread::</span>

<span class="sd">            &gt;&gt;&gt; from sgtk.platform.qt import QtGui</span>
<span class="sd">            &gt;&gt;&gt; engine.execute_in_main_thread(QtGui.QMessageBox.information, None, &quot;Hello&quot;, &quot;Hello from the main thread!&quot;)</span>

<span class="sd">        .. note:: This currently only works if Qt is available, otherwise it just</span>
<span class="sd">                  executes immediately on the current thread.</span>

<span class="sd">        :param func: function to call</span>
<span class="sd">        :param args: arguments to pass to the function</span>
<span class="sd">        :param kwargs: named arguments to pass to the function</span>

<span class="sd">        :returns: the result of the function call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_in_main_thread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SYNC_INVOKER</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Engine.async_execute_in_main_thread"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.async_execute_in_main_thread">[docs]</a>    <span class="k">def</span> <span class="nf">async_execute_in_main_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the specified function in the main thread when called from a non-main</span>
<span class="sd">        thread.  This call will return immediately and will not wait for the code to be</span>
<span class="sd">        executed in the main thread.</span>

<span class="sd">        .. note:: This currently only works if Qt is available, otherwise it just</span>
<span class="sd">                  executes immediately on the current thread.</span>

<span class="sd">        :param func: function to call</span>
<span class="sd">        :param args: arguments to pass to the function</span>
<span class="sd">        :param kwargs: named arguments to pass to the function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execute_in_main_thread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ASYNC_INVOKER</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_execute_in_main_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invoker_id</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the given method and arguments with the specified invoker.</span>
<span class="sd">        If the invoker is not ready or if the calling thread is the main thread,</span>
<span class="sd">        the method is called immediately with it&#39;s arguments.</span>

<span class="sd">        :param invoker_id: Either _ASYNC_INVOKER or _SYNC_INVOKER.</span>
<span class="sd">        :param func: function to call</span>
<span class="sd">        :param args: arguments to pass to the function</span>
<span class="sd">        :param kwargs: named arguments to pass to the function</span>

<span class="sd">        :returns: The return value from the invoker.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Execute in main thread might be called before the invoker is ready.</span>
        <span class="c1"># For example, an engine might use the invoker for logging to the main</span>
        <span class="c1"># thread.</span>
        <span class="n">invoker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invoker</span> <span class="k">if</span> <span class="n">invoker_id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SYNC_INVOKER</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_invoker</span>
        <span class="k">if</span> <span class="n">invoker</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.qt</span> <span class="kn">import</span> <span class="n">QtGui</span><span class="p">,</span> <span class="n">QtCore</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QApplication</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>
                <span class="ow">and</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QThread</span><span class="o">.</span><span class="n">currentThread</span><span class="p">()</span> <span class="o">!=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QApplication</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">thread</span><span class="p">()):</span>
                <span class="c1"># invoke the function on the thread that the QtGui.QApplication was created on.</span>
                <span class="k">return</span> <span class="n">invoker</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we&#39;re already on the main thread so lets just call our function:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we don&#39;t have an invoker so just call the function:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Engine.get_matching_commands"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.get_matching_commands">[docs]</a>    <span class="k">def</span> <span class="nf">get_matching_commands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command_selectors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds all the commands that match the given selectors.</span>

<span class="sd">        Command selector structures are typically found in engine configurations</span>
<span class="sd">        and are typically defined on the following form in yaml::</span>

<span class="sd">            menu_favourites:</span>
<span class="sd">            - {app_instance: tk-multi-workfiles, name: Shotgun File Manager...}</span>
<span class="sd">            - {app_instance: tk-multi-snapshot,  name: Snapshot...}</span>
<span class="sd">            - {app_instance: tk-multi-workfiles, name: Shotgun Save As...}</span>
<span class="sd">            - {app_instance: tk-multi-publish,   name: Publish...}</span>

<span class="sd">        Note that selectors that do not match a command will output a warning.</span>

<span class="sd">        :param command_selectors: A list of command selectors, with each</span>
<span class="sd">                                  selector having the following structure::</span>

<span class="sd">                                      {</span>
<span class="sd">                                        name: command-name,</span>
<span class="sd">                                        app_instance: instance-name</span>
<span class="sd">                                      }</span>

<span class="sd">                                  An empty name (&quot;&quot;) will select all the</span>
<span class="sd">                                  commands of the given instance-name.</span>

<span class="sd">        :returns:                 A list of tuples for all commands that match</span>
<span class="sd">                                  the selectors. Each tuple has the format::</span>

<span class="sd">                                      (instance-name, command-name, callback)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return a dictionary grouping all the commands by instance name</span>
        <span class="n">commands_by_instance</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">app_instance</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">app_instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">instance_name</span> <span class="o">=</span> <span class="n">app_instance</span><span class="o">.</span><span class="n">instance_name</span>
            <span class="n">commands_by_instance</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">instance_name</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="s2">&quot;callback&quot;</span><span class="p">]))</span>

        <span class="c1"># go through the selectors and return any matching commands</span>
        <span class="n">ret_value</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">selector</span> <span class="ow">in</span> <span class="n">command_selectors</span><span class="p">:</span>
            <span class="n">command_name</span> <span class="o">=</span> <span class="n">selector</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="n">instance_name</span> <span class="o">=</span> <span class="n">selector</span><span class="p">[</span><span class="s2">&quot;app_instance&quot;</span><span class="p">]</span>
            <span class="n">instance_commands</span> <span class="o">=</span> <span class="n">commands_by_instance</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instance_name</span><span class="p">,</span> <span class="p">[])</span>

            <span class="c1"># add the commands if the name of the settings is &#39;&#39;</span>
            <span class="c1"># or the name matches</span>
            <span class="n">matching_commands</span> <span class="o">=</span> <span class="p">[(</span><span class="n">instance_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span> <span class="ow">in</span> <span class="n">instance_commands</span>
                                 <span class="k">if</span> <span class="ow">not</span> <span class="n">command_name</span> <span class="ow">or</span> <span class="p">(</span><span class="n">command_name</span> <span class="o">==</span> <span class="n">name</span><span class="p">)]</span>
            <span class="n">ret_value</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">matching_commands</span><span class="p">)</span>

            <span class="c1"># give feedback if no commands were found</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">matching_commands</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">log_warning</span><span class="p">(</span>
                    <span class="s2">&quot;The requested command &#39;</span><span class="si">%s</span><span class="s2">&#39; from app instance &#39;</span><span class="si">%s</span><span class="s2">&#39; could &quot;</span>
                    <span class="s2">&quot;not be matched.</span><span class="se">\n</span><span class="s2">Please make sure that you have the app &quot;</span>
                    <span class="s2">&quot;installed and that it has successfully initialized.&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">command_name</span><span class="p">,</span> <span class="n">instance_name</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ret_value</span></div>

    <span class="c1">##########################################################################################</span>
    <span class="c1"># logging interfaces</span>

<div class="viewcode-block" id="Engine.log_debug"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.log_debug">[docs]</a>    <span class="k">def</span> <span class="nf">log_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logs a debug message.</span>

<span class="sd">        .. deprecated:: 0.18</span>
<span class="sd">            Use :meth:`Engine.logger` instead.</span>

<span class="sd">        .. note:: Toolkit will probe for this method and use it to determine if</span>
<span class="sd">                  the current engine supports the new :meth:`Engine.logger` based logging</span>
<span class="sd">                  or not. If you are developing an engine and want to upgrade it to</span>
<span class="sd">                  use the new logging capabilities, you should remove the</span>
<span class="sd">                  implementation of ``log_debug|error|info|...()`` methods and</span>
<span class="sd">                  instead sublcass :meth:`Engine._emit_log_message`.</span>

<span class="sd">        :param msg: Message to log.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_018_logging_support</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__log_handler</span><span class="o">.</span><span class="n">inside_dispatch</span><span class="p">:</span>
            <span class="c1"># special case: We are in legacy mode and all log messages are</span>
            <span class="c1"># dispatched to the log_xxx methods because this engine does not have an</span>
            <span class="c1"># _emit_log_message implementation. This is fine because typically old</span>
            <span class="c1"># engine implementations subclass the log_xxx class, meaning that this call</span>
            <span class="c1"># is never run, but instead the subclassed code in run. If however, this</span>
            <span class="c1"># could *would* run in that case for whatever reason (either it wasn&#39;t</span>
            <span class="c1"># subclassed or the subclassed code calls the baseclass), we need to be</span>
            <span class="c1"># careful not to end up in an infinite loop. Therefore, the log handler</span>
            <span class="c1"># sets a flag to indicate that this code is being called from the logger</span>
            <span class="c1"># and not from somewhere else. In that case we just exit early to avoid</span>
            <span class="c1"># the infinite recursion</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Engine.log_info"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.log_info">[docs]</a>    <span class="k">def</span> <span class="nf">log_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logs an info message.</span>

<span class="sd">        .. deprecated:: 0.18</span>
<span class="sd">            Use :meth:`Engine.logger` instead.</span>

<span class="sd">        :param msg: Message to log.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_018_logging_support</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__log_handler</span><span class="o">.</span><span class="n">inside_dispatch</span><span class="p">:</span>
            <span class="c1"># special case: We are in legacy mode and all log messages are</span>
            <span class="c1"># dispatched to the log_xxx methods because this engine does not have an</span>
            <span class="c1"># _emit_log_message implementation. This is fine because typically old</span>
            <span class="c1"># engine implementations subclass the log_xxx class, meaning that this call</span>
            <span class="c1"># is never run, but instead the subclassed code in run. If however, this</span>
            <span class="c1"># could *would* run in that case for whatever reason (either it wasn&#39;t</span>
            <span class="c1"># subclassed or the subclassed code calls the baseclass), we need to be</span>
            <span class="c1"># careful not to end up in an infinite loop. Therefore, the log handler</span>
            <span class="c1"># sets a flag to indicate that this code is being called from the logger</span>
            <span class="c1"># and not from somewhere else. In that case we just exit early to avoid</span>
            <span class="c1"># the infinite recursion</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Engine.log_warning"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.log_warning">[docs]</a>    <span class="k">def</span> <span class="nf">log_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logs an warning message.</span>

<span class="sd">        .. deprecated:: 0.18</span>
<span class="sd">            Use :meth:`Engine.logger` instead.</span>

<span class="sd">        :param msg: Message to log.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_018_logging_support</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__log_handler</span><span class="o">.</span><span class="n">inside_dispatch</span><span class="p">:</span>
            <span class="c1"># special case: We are in legacy mode and all log messages are</span>
            <span class="c1"># dispatched to the log_xxx methods because this engine does not have an</span>
            <span class="c1"># _emit_log_message implementation. This is fine because typically old</span>
            <span class="c1"># engine implementations subclass the log_xxx class, meaning that this call</span>
            <span class="c1"># is never run, but instead the subclassed code in run. If however, this</span>
            <span class="c1"># could *would* run in that case for whatever reason (either it wasn&#39;t</span>
            <span class="c1"># subclassed or the subclassed code calls the baseclass), we need to be</span>
            <span class="c1"># careful not to end up in an infinite loop. Therefore, the log handler</span>
            <span class="c1"># sets a flag to indicate that this code is being called from the logger</span>
            <span class="c1"># and not from somewhere else. In that case we just exit early to avoid</span>
            <span class="c1"># the infinite recursion</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Engine.log_error"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.log_error">[docs]</a>    <span class="k">def</span> <span class="nf">log_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logs an error message.</span>

<span class="sd">        .. deprecated:: 0.18</span>
<span class="sd">            Use :meth:`Engine.logger` instead.</span>

<span class="sd">        :param msg: Message to log.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_018_logging_support</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__log_handler</span><span class="o">.</span><span class="n">inside_dispatch</span><span class="p">:</span>
            <span class="c1"># special case: We are in legacy mode and all log messages are</span>
            <span class="c1"># dispatched to the log_xxx methods because this engine does not have an</span>
            <span class="c1"># _emit_log_message implementation. This is fine because typically old</span>
            <span class="c1"># engine implementations subclass the log_xxx class, meaning that this call</span>
            <span class="c1"># is never run, but instead the subclassed code in run. If however, this</span>
            <span class="c1"># could *would* run in that case for whatever reason (either it wasn&#39;t</span>
            <span class="c1"># subclassed or the subclassed code calls the baseclass), we need to be</span>
            <span class="c1"># careful not to end up in an infinite loop. Therefore, the log handler</span>
            <span class="c1"># sets a flag to indicate that this code is being called from the logger</span>
            <span class="c1"># and not from somewhere else. In that case we just exit early to avoid</span>
            <span class="c1"># the infinite recursion</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="Engine.log_exception"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.log_exception">[docs]</a>    <span class="k">def</span> <span class="nf">log_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logs an exception message.</span>

<span class="sd">        .. deprecated:: 0.18</span>
<span class="sd">            Use :meth:`Engine.logger` instead.</span>

<span class="sd">        :param msg: Message to log.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_018_logging_support</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__log_handler</span><span class="o">.</span><span class="n">inside_dispatch</span><span class="p">:</span>
            <span class="c1"># special case: We are in legacy mode and all log messages are</span>
            <span class="c1"># dispatched to the log_xxx methods because this engine does not have an</span>
            <span class="c1"># _emit_log_message implementation. This is fine because typically old</span>
            <span class="c1"># engine implementations subclass the log_xxx class, meaning that this call</span>
            <span class="c1"># is never run, but instead the subclassed code in run. If however, this</span>
            <span class="c1"># could *would* run in that case for whatever reason (either it wasn&#39;t</span>
            <span class="c1"># subclassed or the subclassed code calls the baseclass), we need to be</span>
            <span class="c1"># careful not to end up in an infinite loop. Therefore, the log handler</span>
            <span class="c1"># sets a flag to indicate that this code is being called from the logger</span>
            <span class="c1"># and not from somewhere else. In that case we just exit early to avoid</span>
            <span class="c1"># the infinite recursion</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


    <span class="c1">##########################################################################################</span>
    <span class="c1"># debug for tracking Qt Widgets &amp; Dialogs created by the provided methods      </span>

<div class="viewcode-block" id="Engine.get_debug_tracked_qt_widgets"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.get_debug_tracked_qt_widgets">[docs]</a>    <span class="k">def</span> <span class="nf">get_debug_tracked_qt_widgets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print debug info about created Qt dialogs and widgets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__qt_debug_info</span>                </div>

    <span class="k">def</span> <span class="nf">__debug_track_qt_widget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widget</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the qt widget to a list of objects to be tracked. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">widget</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__qt_debug_info</span><span class="p">[</span><span class="n">widget</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span>
        
    <span class="c1">##########################################################################################</span>
    <span class="c1"># private and protected methods</span>

<div class="viewcode-block" id="Engine._emit_log_message"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine._emit_log_message">[docs]</a>    <span class="k">def</span> <span class="nf">_emit_log_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the engine whenever a new log message is available.</span>
<span class="sd">        All log messages from the toolkit logging namespace will be passed to this method.</span>

<span class="sd">        .. note:: To implement logging in your engine implementation, subclass</span>
<span class="sd">                  this method and display the record in a suitable way - typically</span>
<span class="sd">                  this means sending it to a built-in DCC console. In addition to this,</span>
<span class="sd">                  ensure that your engine implementation *does not* subclass</span>
<span class="sd">                  the (old) :meth:`Engine.log_debug`, :meth:`Engine.log_info` family</span>
<span class="sd">                  of logging methods.</span>

<span class="sd">                  For a consistent output, use the formatter that is associated with</span>
<span class="sd">                  the log handler that is passed in. A basic implementation of</span>
<span class="sd">                  this method could look like this::</span>

<span class="sd">                      # call out to handler to format message in a standard way</span>
<span class="sd">                      msg_str = handler.format(record)</span>

<span class="sd">                      # display message</span>
<span class="sd">                      print msg_str</span>

<span class="sd">        .. warning:: This method may be executing called from worker threads. In DCC</span>
<span class="sd">                     environments, where it is important that the console/logging output</span>
<span class="sd">                     always happens in the main thread, it is recommended that you</span>
<span class="sd">                     use the :meth:`async_execute_in_main_thread` to ensure that your</span>
<span class="sd">                     logging code is writing to the DCC console in the main thread.</span>

<span class="sd">        :param handler: Log handler that this message was dispatched from</span>
<span class="sd">        :type handler: :class:`~python.logging.LogHandler`</span>
<span class="sd">        :param record: Std python logging record</span>
<span class="sd">        :type record: :class:`~python.logging.LogRecord`</span>
<span class="sd">        &quot;&quot;&quot;</span></div>
        <span class="c1"># default implementation doesn&#39;t do anything.</span>


<div class="viewcode-block" id="Engine._get_dialog_parent"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine._get_dialog_parent">[docs]</a>    <span class="k">def</span> <span class="nf">_get_dialog_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the QWidget parent for all dialogs created through :meth:`show_dialog` :meth:`show_modal`.</span>
<span class="sd">        </span>
<span class="sd">        Can be overriden in derived classes to return the QWidget to be used as the parent </span>
<span class="sd">        for all TankQDialog&#39;s.</span>

<span class="sd">        :return: QT Parent window (:class:`PySide.QtGui.QWidget`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># By default, this will return the QApplication&#39;s active window:</span>
        <span class="kn">from</span> <span class="nn">.qt</span> <span class="kn">import</span> <span class="n">QtGui</span>
        <span class="k">return</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QApplication</span><span class="o">.</span><span class="n">activeWindow</span><span class="p">()</span></div>
                
<div class="viewcode-block" id="Engine._create_dialog"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine._create_dialog">[docs]</a>    <span class="k">def</span> <span class="nf">_create_dialog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a TankQDialog with the specified widget embedded. This also connects to the </span>
<span class="sd">        dialogs dialog_closed event so that it can clean up when the dialog is closed.</span>

<span class="sd">        .. note:: For more information, see the documentation for :meth:`show_dialog()`.</span>

<span class="sd">        :param title: The title of the window</span>
<span class="sd">        :param bundle: The app, engine or framework object that is associated with this window</span>
<span class="sd">        :param widget: A QWidget instance to be embedded in the newly created dialog.</span>
<span class="sd">        :type widget: :class:`PySide.QtGui.QWidget`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.qt</span> <span class="kn">import</span> <span class="n">tankqdialog</span>
        
        <span class="c1"># create a dialog to put it inside</span>
        <span class="n">dialog</span> <span class="o">=</span> <span class="n">tankqdialog</span><span class="o">.</span><span class="n">TankQDialog</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>

        <span class="c1"># keep a reference to all created dialogs to make GC happy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__created_qt_dialogs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dialog</span><span class="p">)</span>
        
        <span class="c1"># watch for the dialog closing so that we can clean up</span>
        <span class="n">dialog</span><span class="o">.</span><span class="n">dialog_closed</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_dialog_closed</span><span class="p">)</span>
        
        <span class="c1"># keep track of some info for debugging object lifetime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__debug_track_qt_widget</span><span class="p">(</span><span class="n">dialog</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">dialog</span></div>

<div class="viewcode-block" id="Engine._create_widget"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine._create_widget">[docs]</a>    <span class="k">def</span> <span class="nf">_create_widget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widget_class</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of the specified widget_class.  This wraps the widget_class so that </span>
<span class="sd">        the TankQDialog it is embedded in can connect to it more easily in order to handle the </span>
<span class="sd">        close event.</span>

<span class="sd">        When overriding in a derived engine, be sure to call the base implementations of</span>
<span class="sd">        :meth:`_create_widget()` and :meth:`_create_dialog()` to ensure that all</span>
<span class="sd">        dialogs and widgets are tracked efficiently and safely.</span>

<span class="sd">        .. note:: For more information, see the documentation for :meth:`show_dialog()`.</span>

<span class="sd">        :param widget_class: The class of the UI to be constructed. This must derive from QWidget.</span>
<span class="sd">        :type widget_class: :class:`PySide.QtGui.QWidget`</span>
<span class="sd">            </span>
<span class="sd">        Additional parameters specified will be passed through to the widget_class constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.qt</span> <span class="kn">import</span> <span class="n">tankqdialog</span>
                
        <span class="c1"># construct the widget object</span>
        <span class="n">derived_widget_class</span> <span class="o">=</span> <span class="n">tankqdialog</span><span class="o">.</span><span class="n">TankQDialog</span><span class="o">.</span><span class="n">wrap_widget_class</span><span class="p">(</span><span class="n">widget_class</span><span class="p">)</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">derived_widget_class</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c1"># keep track of some info for debugging object lifetime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__debug_track_qt_widget</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">widget</span></div>
    
<div class="viewcode-block" id="Engine._create_dialog_with_widget"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine._create_dialog_with_widget">[docs]</a>    <span class="k">def</span> <span class="nf">_create_dialog_with_widget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget_class</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method to create an sgtk TankQDialog with a widget instantiated from </span>
<span class="sd">        widget_class embedded in the main section.</span>

<span class="sd">        .. note:: For more information, see the documentation for :meth:`show_dialog()`.</span>

<span class="sd">        :param title: The title of the window</span>
<span class="sd">        :param bundle: The app, engine or framework object that is associated with this window</span>
<span class="sd">        :param widget_class: The class of the UI to be constructed. This must derive from QWidget.</span>
<span class="sd">        :type widget_class: :class:`PySide.QtGui.QWidget`</span>
<span class="sd">            </span>
<span class="sd">        Additional parameters specified will be passed through to the widget_class constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the parent for the dialog:</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dialog_parent</span><span class="p">()</span>
        
        <span class="c1"># create the widget:</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_widget</span><span class="p">(</span><span class="n">widget_class</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c1"># apply style sheet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_external_styleshet</span><span class="p">(</span><span class="n">bundle</span><span class="p">,</span> <span class="n">widget</span><span class="p">)</span>        
        
        <span class="c1"># create the dialog:</span>
        <span class="n">dialog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_dialog</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">dialog</span><span class="p">,</span> <span class="n">widget</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Engine._on_dialog_closed"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine._on_dialog_closed">[docs]</a>    <span class="k">def</span> <span class="nf">_on_dialog_closed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dlg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when a dialog created by this engine is closed.</span>
<span class="sd">        </span>
<span class="sd">        :param dlg: The dialog being closed</span>
<span class="sd">        :type dlg: :class:`PySide.QtGui.QWidget`</span>

<span class="sd">        Derived implementations of this method should be sure to call</span>
<span class="sd">        the base implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first, detach the widget from the dialog.  This allows</span>
        <span class="c1"># the two objects to be cleaned up seperately menaing the</span>
        <span class="c1"># lifetime of the widget can be better managed</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">dlg</span><span class="o">.</span><span class="n">detach_widget</span><span class="p">()</span>
        
        <span class="c1"># add the dlg and it&#39;s contained widget to the list</span>
        <span class="c1"># of widgets to delete at some point!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__qt_widget_trash</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dlg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__qt_widget_trash</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">dlg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__created_qt_dialogs</span><span class="p">:</span>
            <span class="c1"># don&#39;t need to track this dialog any longer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__created_qt_dialogs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dlg</span><span class="p">)</span>
            
        <span class="c1"># disconnect from the dialog:</span>
        <span class="n">dlg</span><span class="o">.</span><span class="n">dialog_closed</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_dialog_closed</span><span class="p">)</span>
        
        <span class="c1"># clear temps</span>
        <span class="n">dlg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c1"># finally, clean up the widget trash:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cleanup_widget_trash</span><span class="p">()</span></div>
        

    <span class="k">def</span> <span class="nf">__cleanup_widget_trash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run through the widget trash and clean up any widgets</span>
<span class="sd">        that are no longer referenced by anything else.</span>
<span class="sd">        </span>
<span class="sd">        Notes:  This is pretty dumb and only looks at reference</span>
<span class="sd">        counts.  This means that if a widget has cyclic references</span>
<span class="sd">        then it will never get released.</span>
<span class="sd">        </span>
<span class="sd">        Better to be safe though as deleting/releasing a widget that</span>
<span class="sd">        still has events in the event queue will cause a hard crash!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">still_trash</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">widget</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__qt_widget_trash</span><span class="p">:</span>
            <span class="c1"># There should be 3 references:</span>
            <span class="c1"># 1. self.__qt_widget_trash[n]</span>
            <span class="c1"># 2. widget temporary</span>
            <span class="c1"># 3. temporary used by sys.getrefcount</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># we have the only references to the widget</span>
                <span class="c1"># so lets delete it!</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">widget</span><span class="o">.</span><span class="n">deleteLater</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                    <span class="c1"># this is most likely because the Qt C++ widget has </span>
                    <span class="c1"># already been deleted elsewhere so we can safely </span>
                    <span class="c1"># ignore it!</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># there are still other references to this widget </span>
                <span class="c1"># out there so we should still keep track of it</span>
                <span class="n">still_trash</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span>
    
        <span class="c1"># update widget trash</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__qt_widget_trash</span> <span class="o">=</span> <span class="n">still_trash</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Widget trash contains </span><span class="si">%d</span><span class="s2"> widgets&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__qt_widget_trash</span><span class="p">)))</span>

<div class="viewcode-block" id="Engine.show_dialog"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.show_dialog">[docs]</a>    <span class="k">def</span> <span class="nf">show_dialog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget_class</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shows a non-modal dialog window in a way suitable for this engine. </span>
<span class="sd">        The engine will attempt to parent the dialog nicely to the host application.</span>
<span class="sd">        The dialog will be created with a standard Toolkit window title bar where</span>
<span class="sd">        the title will be displayed.</span>

<span class="sd">        .. note:: In some cases, it is necessary to hide the standard Toolkit title</span>
<span class="sd">                  bar. You can do this by adding a property to the widget class you are</span>
<span class="sd">                  displaying::</span>

<span class="sd">                        @property</span>
<span class="sd">                        def hide_tk_title_bar(self):</span>
<span class="sd">                            &quot;Tell the system to not show the standard toolkit toolbar&quot;</span>
<span class="sd">                            return True</span>

<span class="sd">        **Notes for engine developers**</span>

<span class="sd">        Qt dialog &amp; widget management can be quite tricky in different engines/applications.</span>
<span class="sd">        Because of this, Sgtk provides a few overridable methods with the idea being that when</span>
<span class="sd">        developing a new engine, you only need to override the minimum amount necessary.</span>

<span class="sd">        Making use of these methods in the correct way allows the base Engine class to manage the</span>
<span class="sd">        lifetime of the dialogs and widgets efficiently and safely without you having to worry about it.</span>

<span class="sd">        The methods available are listed here in the hierarchy in which they are called::</span>

<span class="sd">            show_dialog()/show_modal()</span>
<span class="sd">                _create_dialog_with_widget()</span>
<span class="sd">                    _get_dialog_parent()</span>
<span class="sd">                    _create_widget()</span>
<span class="sd">                    _create_dialog()</span>

<span class="sd">        For example, if you just need to make sure that all dialogs use a specific parent widget</span>
<span class="sd">        then you only need to override _get_dialog_parent() (e.g. the tk-maya engine).</span>
<span class="sd">        However, if you need to implement a two-stage creation then you may need to re-implement</span>
<span class="sd">        show_dialog() and show_modal() to call _create_widget() and _create_dialog() directly rather</span>
<span class="sd">        than using the helper method _create_dialog_with_widget() (e.g. the tk-3dsmax engine).</span>
<span class="sd">        Finally, if the application you are writing an engine for is Qt based then you may not need</span>
<span class="sd">        to override any of these methods (e.g. the tk-nuke engine).</span>

<span class="sd">        :param title: The title of the window. This will appear in the Toolkit title bar.</span>
<span class="sd">        :param bundle: The app, engine or framework object that is associated with this window</span>
<span class="sd">        :param widget_class: The class of the UI to be constructed. This must derive from QWidget.</span>
<span class="sd">        :type widget_class: :class:`PySide.QtGui.QWidget`</span>

<span class="sd">        Additional parameters specified will be passed through to the widget_class constructor.</span>
<span class="sd">        </span>
<span class="sd">        :returns: the created widget_class instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ui</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;Sorry, this environment does not support UI display! Cannot show &quot;</span>
                           <span class="s2">&quot;the requested window &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">title</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="c1"># create the dialog:</span>
        <span class="n">dialog</span><span class="p">,</span> <span class="n">widget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_dialog_with_widget</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget_class</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c1"># show the dialog        </span>
        <span class="n">dialog</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
        <span class="c1"># lastly, return the instantiated widget</span>
        <span class="k">return</span> <span class="n">widget</span></div>
    
<div class="viewcode-block" id="Engine.show_modal"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.show_modal">[docs]</a>    <span class="k">def</span> <span class="nf">show_modal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget_class</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shows a modal dialog window in a way suitable for this engine. The engine will attempt to</span>
<span class="sd">        integrate it as seamlessly as possible into the host application. This call is blocking </span>
<span class="sd">        until the user closes the dialog.</span>
<span class="sd">        The dialog will be created with a standard Toolkit window title bar where</span>
<span class="sd">        the title will be displayed.</span>

<span class="sd">        .. note:: In some cases, it is necessary to hide the standard Toolkit title</span>
<span class="sd">                  bar. You can do this by adding a property to the widget class you are</span>
<span class="sd">                  displaying::</span>

<span class="sd">                        @property</span>
<span class="sd">                        def hide_tk_title_bar(self):</span>
<span class="sd">                            &quot;Tell the system to not show the standard toolkit toolbar&quot;</span>
<span class="sd">                            return True</span>
<span class="sd">        </span>
<span class="sd">        :param title: The title of the window</span>
<span class="sd">        :param bundle: The app, engine or framework object that is associated with this window</span>
<span class="sd">        :param widget_class: The class of the UI to be constructed. This must derive from QWidget.</span>
<span class="sd">        :type widget_class: :class:`PySide.QtGui.QWidget`</span>

<span class="sd">        Additional parameters specified will be passed through to the widget_class constructor.</span>

<span class="sd">        :returns: (a standard QT dialog status return code, the created widget_class instance)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ui</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;Sorry, this environment does not support UI display! Cannot show &quot;</span>
                           <span class="s2">&quot;the requested window &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">title</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="c1"># create the dialog:</span>
        <span class="n">dialog</span><span class="p">,</span> <span class="n">widget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_dialog_with_widget</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget_class</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c1"># finally launch it, modal state</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
        
        <span class="c1"># lastly, return the instantiated widget</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">widget</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="Engine.show_panel"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine.show_panel">[docs]</a>    <span class="k">def</span> <span class="nf">show_panel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">panel_id</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget_class</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shows a panel in a way suitable for this engine. Engines should attempt to</span>
<span class="sd">        integrate panel support as seamlessly as possible into the host application. </span>
<span class="sd">        Some engines have extensive panel support and workflows, others have none at all.</span>
<span class="sd">        </span>
<span class="sd">        If the engine does not specifically implement panel support, the window will </span>
<span class="sd">        be shown as a modeless dialog instead and the call is equivalent to </span>
<span class="sd">        calling :meth:`show_dialog()`.</span>

<span class="sd">        The dialog will be created with a standard Toolkit window title bar where</span>
<span class="sd">        the title will be displayed.</span>

<span class="sd">        .. note:: In some cases, it is necessary to hide the standard Toolkit title</span>
<span class="sd">                  bar. You can do this by adding a property to the widget class you are</span>
<span class="sd">                  displaying::</span>

<span class="sd">                        @property</span>
<span class="sd">                        def hide_tk_title_bar(self):</span>
<span class="sd">                            &quot;Tell the system to not show the standard toolkit toolbar&quot;</span>
<span class="sd">                            return True</span>

<span class="sd">        :param panel_id: Unique identifier for the panel, as obtained by register_panel().</span>
<span class="sd">        :param title: The title of the panel</span>
<span class="sd">        :param bundle: The app, engine or framework object that is associated with this window</span>
<span class="sd">        :param widget_class: The class of the UI to be constructed. This must derive from QWidget.</span>
<span class="sd">        :type widget_class: :class:`PySide.QtGui.QWidget`</span>

<span class="sd">        Additional parameters specified will be passed through to the widget_class constructor.</span>
<span class="sd">        </span>
<span class="sd">        :returns: the created widget_class instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># engines implementing panel support should subclass this method.</span>
        <span class="c1"># the core implementation falls back on a modeless window.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_warning</span><span class="p">(</span><span class="s2">&quot;Panel functionality not implemented. Falling back to showing &quot;</span>
                         <span class="s2">&quot;panel &#39;</span><span class="si">%s</span><span class="s2">&#39; in a modeless dialog&quot;</span> <span class="o">%</span> <span class="n">panel_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_dialog</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget_class</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>        </div>


    <span class="k">def</span> <span class="nf">_resolve_sg_stylesheet_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">style_sheet</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a string containing a qt style sheet,</span>
<span class="sd">        perform replacements of key toolkit tokens.</span>
<span class="sd">        </span>
<span class="sd">        For example, &quot;{{SG_HIGHLIGHT_COLOR}}&quot; is converted to &quot;#30A7E3&quot;</span>
<span class="sd">        </span>
<span class="sd">        :param style_sheet: Stylesheet string to process</span>
<span class="sd">        :returns: Stylesheet string with replacements applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">processed_style_sheet</span> <span class="o">=</span> <span class="n">style_sheet</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">SG_STYLESHEET_CONSTANTS</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">processed_style_sheet</span> <span class="o">=</span> <span class="n">processed_style_sheet</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;{{</span><span class="si">%s</span><span class="s2">}}&quot;</span> <span class="o">%</span> <span class="n">token</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">processed_style_sheet</span>
    
    <span class="k">def</span> <span class="nf">_apply_external_styleshet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">widget</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply an std external stylesheet, associated with a bundle, to a widget.</span>
<span class="sd">        </span>
<span class="sd">        This will check if a standard style.css file exists in the</span>
<span class="sd">        app/engine/framework root location on disk and if so load it from </span>
<span class="sd">        disk and apply to the given widget. The style sheet is cascading, meaning </span>
<span class="sd">        that it will affect all children of the given widget. Typically this is used</span>
<span class="sd">        at window creation in order to allow newly created dialogs to apply app specific</span>
<span class="sd">        styles easily.</span>
<span class="sd">        </span>
<span class="sd">        :param bundle: app/engine/framework instance to load style sheet from</span>
<span class="sd">        :param widget: widget to apply stylesheet to </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">qss_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bundle</span><span class="o">.</span><span class="n">disk_location</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">BUNDLE_STYLESHEET_FILE</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">qss_file</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Read css file</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Detected std style sheet file &#39;</span><span class="si">%s</span><span class="s2">&#39; - applying to widget </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">qss_file</span><span class="p">,</span> <span class="n">widget</span><span class="p">))</span>
                <span class="n">qss_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="c1"># resolve tokens</span>
                <span class="n">qss_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_sg_stylesheet_tokens</span><span class="p">(</span><span class="n">qss_data</span><span class="p">)</span>
                <span class="c1"># apply to widget (and all its children)</span>
                <span class="n">widget</span><span class="o">.</span><span class="n">setStyleSheet</span><span class="p">(</span><span class="n">qss_data</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># catch-all and issue a warning and continue.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_warning</span><span class="p">(</span><span class="s2">&quot;Could not apply stylesheet &#39;</span><span class="si">%s</span><span class="s2">&#39;: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">qss_file</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="c1"># The file didn&#39;t exist, so nothing to do.</span>
            <span class="k">pass</span>

<div class="viewcode-block" id="Engine._define_qt_base"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine._define_qt_base">[docs]</a>    <span class="k">def</span> <span class="nf">_define_qt_base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This will be called at initialisation time and will allow </span>
<span class="sd">        a user to control various aspects of how QT is being used</span>
<span class="sd">        by Tank. The method should return a dictionary with a number</span>
<span class="sd">        of specific keys, outlined below. </span>
<span class="sd">        </span>
<span class="sd">        * qt_core - the QtCore module to use</span>
<span class="sd">        * qt_gui - the QtGui module to use</span>
<span class="sd">        * dialog_base - base class for to use for Tank&#39;s dialog factory</span>
<span class="sd">        </span>
<span class="sd">        :returns: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># default to None</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;qt_core&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;qt_gui&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;dialog_base&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">PySide</span> <span class="kn">import</span> <span class="n">QtCore</span><span class="p">,</span> <span class="n">QtGui</span>
            <span class="n">base</span><span class="p">[</span><span class="s2">&quot;qt_core&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QtCore</span>
            <span class="n">base</span><span class="p">[</span><span class="s2">&quot;qt_gui&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QtGui</span>
            <span class="n">base</span><span class="p">[</span><span class="s2">&quot;dialog_base&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QDialog</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Default engine QT definition failed to find QT. &quot;</span>
                           <span class="s2">&quot;This may need to be subclassed.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">base</span></div>
        
<div class="viewcode-block" id="Engine._initialize_dark_look_and_feel"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.Engine._initialize_dark_look_and_feel">[docs]</a>    <span class="k">def</span> <span class="nf">_initialize_dark_look_and_feel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a standard toolkit look and feel using a combination of</span>
<span class="sd">        QPalette and stylesheets.</span>
<span class="sd">        </span>
<span class="sd">        If your engine is running inside an environment which already has</span>
<span class="sd">        a dark style defined, do not call this method. The Toolkit apps are </span>
<span class="sd">        designed to work well with most dark themes.</span>
<span class="sd">        </span>
<span class="sd">        However, if you are for example creating your own QApplication instance</span>
<span class="sd">        you can execute this method to but the session into Toolkit&#39;s </span>
<span class="sd">        standard dark mode.</span>
<span class="sd">        </span>
<span class="sd">        This will initialize the plastique style and set it up with a standard</span>
<span class="sd">        dark palette and supporting stylesheet.</span>
<span class="sd">        </span>
<span class="sd">        Apps and UIs can then extend this further by using further css.</span>
<span class="sd">        </span>
<span class="sd">        Due to restrictions in QT, this needs to run after a QApplication object</span>
<span class="sd">        has been instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.qt</span> <span class="kn">import</span> <span class="n">QtGui</span><span class="p">,</span> <span class="n">QtCore</span>

        <span class="c1"># initialize our style</span>
        <span class="n">QtGui</span><span class="o">.</span><span class="n">QApplication</span><span class="o">.</span><span class="n">setStyle</span><span class="p">(</span><span class="s2">&quot;plastique&quot;</span><span class="p">)</span>
        
        <span class="c1"># Read in a serialized version of a palette</span>
        <span class="c1"># this file was generated in the following way:</span>
        <span class="c1">#</span>
        <span class="c1"># Inside of maya 2014, the following code was executed:</span>
        <span class="c1">#</span>
        <span class="c1"># from PySide import QtGui, QtCore</span>
        <span class="c1"># app = QtCore.QCoreApplication.instance()</span>
        <span class="c1"># fh = QtCore.QFile(&quot;/tmp/palette.dump&quot;)</span>
        <span class="c1"># fh.open(QtCore.QIODevice.WriteOnly)</span>
        <span class="c1"># out = QtCore.QDataStream(fh)</span>
        <span class="c1"># out.__lshift__( app.palette() )</span>
        <span class="c1"># fh.close()</span>
        <span class="c1">#</span>
        <span class="c1"># When we load this up in our engine, we will get a look</span>
        <span class="c1"># and feel similar to that of maya.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># open palette file</span>
            <span class="n">palette_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_platform_resource_file</span><span class="p">(</span><span class="s2">&quot;dark_palette.qpalette&quot;</span><span class="p">)</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QFile</span><span class="p">(</span><span class="n">palette_file</span><span class="p">)</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QIODevice</span><span class="o">.</span><span class="n">ReadOnly</span><span class="p">);</span>
            <span class="n">file_in</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QDataStream</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
    
            <span class="c1"># deserialize the palette</span>
            <span class="c1"># (store it for GC purposes)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dark_palette</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QPalette</span><span class="p">()</span>
            <span class="n">file_in</span><span class="o">.</span><span class="n">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dark_palette</span><span class="p">)</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
            <span class="c1"># set the std selection bg color to be &#39;shotgun blue&#39;</span>
            <span class="n">highlight_color</span> <span class="o">=</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QBrush</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QColor</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">SG_STYLESHEET_CONSTANTS</span><span class="p">[</span><span class="s2">&quot;SG_HIGHLIGHT_COLOR&quot;</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dark_palette</span><span class="o">.</span><span class="n">setBrush</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QPalette</span><span class="o">.</span><span class="n">Highlight</span><span class="p">,</span> <span class="n">highlight_color</span><span class="p">)</span>

            <span class="c1"># update link colors</span>
            <span class="n">fg_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dark_palette</span><span class="o">.</span><span class="n">color</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QPalette</span><span class="o">.</span><span class="n">Text</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dark_palette</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QPalette</span><span class="o">.</span><span class="n">Link</span><span class="p">,</span> <span class="n">fg_color</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dark_palette</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QPalette</span><span class="o">.</span><span class="n">LinkVisited</span><span class="p">,</span> <span class="n">fg_color</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_dark_palette</span><span class="o">.</span><span class="n">setBrush</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QPalette</span><span class="o">.</span><span class="n">HighlightedText</span><span class="p">,</span> <span class="n">QtGui</span><span class="o">.</span><span class="n">QBrush</span><span class="p">(</span><span class="n">QtGui</span><span class="o">.</span><span class="n">QColor</span><span class="p">(</span><span class="s2">&quot;#FFFFFF&quot;</span><span class="p">)))</span>
            
            <span class="c1"># and associate it with the qapplication</span>
            <span class="n">QtGui</span><span class="o">.</span><span class="n">QApplication</span><span class="o">.</span><span class="n">setPalette</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dark_palette</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;The standard toolkit dark palette could not be set up! The look and feel of your &quot;</span>
                           <span class="s2">&quot;toolkit apps may be sub standard. Please contact support. Details: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
            
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># read css</span>
            <span class="n">css_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_platform_resource_file</span><span class="p">(</span><span class="s2">&quot;dark_palette.css&quot;</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">css_file</span><span class="p">)</span>
            <span class="n">css_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">css_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_sg_stylesheet_tokens</span><span class="p">(</span><span class="n">css_data</span><span class="p">)</span>
            <span class="n">app</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QCoreApplication</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>
            
            <span class="n">app</span><span class="o">.</span><span class="n">setStyleSheet</span><span class="p">(</span><span class="n">css_data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;The standard toolkit dark stylesheet could not be set up! The look and feel of your &quot;</span>
                           <span class="s2">&quot;toolkit apps may be sub standard. Please contact support. Details: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span></div>
        
    
    <span class="k">def</span> <span class="nf">_get_standard_qt_stylesheet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **********************************************************************</span>
<span class="sd">        THIS METHOD HAS BEEN DEPRECATED AND SHOULD NOT BE USED!</span>
<span class="sd">        Instead, call _initialize_standard_look_and_feel()</span>
<span class="sd">        **********************************************************************</span>
<span class="sd">        </span>
<span class="sd">        For environments which do not have a well defined QT style sheet,</span>
<span class="sd">        Toolkit maintains a &quot;standard style&quot; which is similar to the look and</span>
<span class="sd">        feel that Maya and Nuke has. </span>
<span class="sd">        </span>
<span class="sd">        This is intended to be used in conjunction with QTs cleanlooks mode.</span>
<span class="sd">        The init code inside an engine would typically look something like this:</span>
<span class="sd">        </span>
<span class="sd">            QtGui.QApplication.setStyle(&quot;cleanlooks&quot;)</span>
<span class="sd">            qt_application = QtGui.QApplication([])</span>
<span class="sd">            qt_application.setStyleSheet( self._get_standard_qt_stylesheet() )         </span>
<span class="sd">        </span>
<span class="sd">        :returns: The style sheet data, as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">css_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_platform_resource_file</span><span class="p">(</span><span class="s2">&quot;toolkit_std_dark.css&quot;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">css_file</span><span class="p">)</span>
        <span class="n">css_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">css_data</span>

    <span class="k">def</span> <span class="nf">_register_shared_framework</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance_name</span><span class="p">,</span> <span class="n">fw_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a framework with the specified instance name.</span>
<span class="sd">        This allows framework instances to be shared between bundles.</span>
<span class="sd">        This method is exposed for use by the platform.framework module.</span>
<span class="sd">        </span>
<span class="sd">        :param instance_name: Name of framework instance, as defined in the</span>
<span class="sd">                              environment. For example &#39;tk-framework-widget_v1.x.x&#39;  </span>
<span class="sd">        :param fw_obj: Framework object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__shared_frameworks</span><span class="p">[</span><span class="n">instance_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fw_obj</span>

    <span class="k">def</span> <span class="nf">_get_shared_framework</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a framework instance by name. If no framework with the specified</span>
<span class="sd">        name has been loaded yet, None is returned.</span>
<span class="sd">        This method is exposed for use by the platform.framework module.</span>
<span class="sd">        </span>
<span class="sd">        :param instance_name: Name of framework instance, as defined in the</span>
<span class="sd">                              environment. For example &#39;tk-framework-widget_v1.x.x&#39;        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shared_frameworks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instance_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__create_invokers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the object used to invoke function calls on the main thread when</span>
<span class="sd">        called from a different thread.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invoker</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">async_invoker</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ui</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.qt</span> <span class="kn">import</span> <span class="n">QtGui</span><span class="p">,</span> <span class="n">QtCore</span>
            <span class="c1"># Classes are defined locally since Qt might not be available.</span>
            <span class="k">if</span> <span class="n">QtGui</span> <span class="ow">and</span> <span class="n">QtCore</span><span class="p">:</span>
                <span class="k">class</span> <span class="nc">Invoker</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QObject</span><span class="p">):</span>
                    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Invoker class - implements a mechanism to execute a function with arbitrary</span>
<span class="sd">                    args in the main thread.</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        Construction</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="n">QtCore</span><span class="o">.</span><span class="n">QObject</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_fn</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="o">=</span> <span class="bp">None</span>

                    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        Invoke the specified function with the specified args in the main thread</span>

<span class="sd">                        :param fn:          The function to execute in the main thread</span>
<span class="sd">                        :param *args:       Args for the function</span>
<span class="sd">                        :param **kwargs:    Named arguments for the function</span>
<span class="sd">                        :returns:           The result returned by the function</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="c1"># acquire lock to ensure that the function and result are not overwritten</span>
                        <span class="c1"># by syncrounous calls to this method from different threads</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_fn</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="o">=</span> <span class="bp">None</span>

                            <span class="c1"># invoke the internal _do_invoke method that will actually run the function.  Note that</span>
                            <span class="c1"># we are unable to pass/return arguments through invokeMethod as this isn&#39;t properly</span>
                            <span class="c1"># supported by PySide.</span>
                            <span class="n">QtCore</span><span class="o">.</span><span class="n">QMetaObject</span><span class="o">.</span><span class="n">invokeMethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_do_invoke&quot;</span><span class="p">,</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">BlockingQueuedConnection</span><span class="p">)</span>

                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span>
                        <span class="k">finally</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

                    <span class="nd">@qt.QtCore.Slot</span><span class="p">()</span>
                    <span class="k">def</span> <span class="nf">_do_invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        Execute the function</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fn</span><span class="p">()</span>

                <span class="k">class</span> <span class="nc">AsyncInvoker</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QObject</span><span class="p">):</span>
                    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Invoker class - implements a mechanism to execute a function with arbitrary</span>
<span class="sd">                    args in the main thread asynchronously.</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="n">__signal</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

                    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        Construction</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="n">QtCore</span><span class="o">.</span><span class="n">QObject</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__execute_in_main_thread</span><span class="p">)</span>

                    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        Invoke the specified function with the specified args in the main thread</span>

<span class="sd">                        :param fn:          The function to execute in the main thread</span>
<span class="sd">                        :param *args:       Args for the function</span>
<span class="sd">                        :param **kwargs:    Named arguments for the function</span>
<span class="sd">                        :returns:           The result returned by the function</span>
<span class="sd">                        &quot;&quot;&quot;</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

                    <span class="k">def</span> <span class="nf">__execute_in_main_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
                        <span class="n">fn</span><span class="p">()</span>

                <span class="c1"># Make sure that the invoker exists in the main thread:</span>
                <span class="n">invoker</span> <span class="o">=</span> <span class="n">Invoker</span><span class="p">()</span>
                <span class="n">async_invoker</span> <span class="o">=</span> <span class="n">AsyncInvoker</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QCoreApplication</span><span class="o">.</span><span class="n">instance</span><span class="p">():</span>
                    <span class="n">invoker</span><span class="o">.</span><span class="n">moveToThread</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QCoreApplication</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">thread</span><span class="p">())</span>
                    <span class="n">async_invoker</span><span class="o">.</span><span class="n">moveToThread</span><span class="p">(</span><span class="n">QtCore</span><span class="o">.</span><span class="n">QCoreApplication</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">thread</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">invoker</span><span class="p">,</span> <span class="n">async_invoker</span>

    <span class="c1">##########################################################################################</span>
    <span class="c1"># private         </span>
        
    <span class="k">def</span> <span class="nf">__load_apps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reuse_existing_apps</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">old_context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate the __applications dictionary, skip over apps that fail to initialize.</span>

<span class="sd">        :param reuse_existing_apps:     Whether to use already-running apps rather than</span>
<span class="sd">                                        starting up a new instance. This is primarily</span>
<span class="sd">                                        used during context changes. Default is False.</span>
<span class="sd">        :param old_context:             In the event of a context change occurring, this</span>
<span class="sd">                                        represents the context being changed away from,</span>
<span class="sd">                                        which will be provided along with the current</span>
<span class="sd">                                        context to each reused app&#39;s post_context_change</span>
<span class="sd">                                        method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this is a load as part of a context change, the applications</span>
        <span class="c1"># dict will already have stuff in it. We can explicitly clean that</span>
        <span class="c1"># out here since those apps also exist in self.__application_pool,</span>
        <span class="c1"># which is persistent.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__applications</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># The commands dict will be repopulated either by new app inits,</span>
        <span class="c1"># or by pulling existing commands for reused apps from the persistant</span>
        <span class="c1"># cache of commands.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__register_reload_command</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">app_instance_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">get_apps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__engine_instance_name</span><span class="p">):</span>
            <span class="c1"># Get a handle to the app bundle.</span>
            <span class="n">descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">get_app_descriptor</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__engine_instance_name</span><span class="p">,</span>
                <span class="n">app_instance_name</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">exists_local</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;Cannot start app! </span><span class="si">%s</span><span class="s2"> does not exist on disk.&quot;</span> <span class="o">%</span> <span class="n">descriptor</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Load settings for app - skip over the ones that don&#39;t validate</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># get the app settings data and validate it.</span>
                <span class="n">app_schema</span> <span class="o">=</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">configuration_schema</span>
                <span class="n">app_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">get_app_settings</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__engine_instance_name</span><span class="p">,</span>
                    <span class="n">app_instance_name</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># check that the context contains all the info that the app needs</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__engine_instance_name</span> <span class="o">!=</span> <span class="n">constants</span><span class="o">.</span><span class="n">SHOTGUN_ENGINE_NAME</span><span class="p">:</span> 
                    <span class="c1"># special case! The shotgun engine is special and does not have a </span>
                    <span class="c1"># context until you actually run a command, so disable the validation.</span>
                    <span class="n">validation</span><span class="o">.</span><span class="n">validate_context</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
                
                <span class="c1"># make sure the current operating system platform is supported</span>
                <span class="n">validation</span><span class="o">.</span><span class="n">validate_platform</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span>
                                
                <span class="c1"># for multi engine apps, make sure our engine is supported</span>
                <span class="n">supported_engines</span> <span class="o">=</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">supported_engines</span>
                <span class="k">if</span> <span class="n">supported_engines</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_engines</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;The app could not be loaded since it only supports &quot;</span>
                                    <span class="s2">&quot;the following engines: </span><span class="si">%s</span><span class="s2">. Your current engine has been &quot;</span>
                                    <span class="s2">&quot;identified as &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">supported_engines</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                
                <span class="c1"># now validate the configuration                </span>
                <span class="n">validation</span><span class="o">.</span><span class="n">validate_settings</span><span class="p">(</span>
                    <span class="n">app_instance_name</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tank</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                    <span class="n">app_schema</span><span class="p">,</span>
                    <span class="n">app_settings</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">except</span> <span class="n">TankError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># validation error - probably some issue with the settings!</span>
                <span class="c1"># report this as an error message.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;App configuration Error for </span><span class="si">%s</span><span class="s2"> (configured in environment &#39;</span><span class="si">%s</span><span class="s2">&#39;). &quot;</span>
                               <span class="s2">&quot;It will not be loaded: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">app_instance_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">disk_location</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                <span class="k">continue</span>
            
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># code execution error in the validation. Report this as an error </span>
                <span class="c1"># with the engire call stack!</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_exception</span><span class="p">(</span><span class="s2">&quot;A general exception was caught while trying to &quot;</span>
                                   <span class="s2">&quot;validate the configuration loaded from &#39;</span><span class="si">%s</span><span class="s2">&#39; for app </span><span class="si">%s</span><span class="s2">. &quot;</span>
                                   <span class="s2">&quot;The app will not be loaded.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="o">.</span><span class="n">disk_location</span><span class="p">,</span> <span class="n">app_instance_name</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="c1"># If we&#39;re told to reuse existing app instances, check for it and</span>
            <span class="c1"># continue if it&#39;s already there. This is most likely a context</span>
            <span class="c1"># change that&#39;s in progress, which means we only want to load apps</span>
            <span class="c1"># that aren&#39;t already up and running.</span>
            <span class="n">install_path</span> <span class="o">=</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
            <span class="n">app_pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__application_pool</span>

            <span class="k">if</span> <span class="n">reuse_existing_apps</span> <span class="ow">and</span> <span class="n">install_path</span> <span class="ow">in</span> <span class="n">app_pool</span><span class="p">:</span>
                <span class="c1"># If we were given an &quot;old&quot; context that&#39;s being switched away</span>
                <span class="c1"># from, we can run the post change method and do a bit of</span>
                <span class="c1"># reinitialization of certain portions of the app.</span>
                <span class="k">if</span> <span class="n">old_context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">app_instance_name</span> <span class="ow">in</span> <span class="n">app_pool</span><span class="p">[</span><span class="n">install_path</span><span class="p">]:</span>
                    <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__application_pool</span><span class="p">[</span><span class="n">install_path</span><span class="p">][</span><span class="n">app_instance_name</span><span class="p">]</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Update the app&#39;s internal context pointer.</span>
                        <span class="n">app</span><span class="o">.</span><span class="n">_set_context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>

                        <span class="c1"># Update the app settings.</span>
                        <span class="n">app</span><span class="o">.</span><span class="n">_set_settings</span><span class="p">(</span><span class="n">app_settings</span><span class="p">)</span>

                        <span class="c1"># Set the instance name.</span>
                        <span class="n">app</span><span class="o">.</span><span class="n">instance_name</span> <span class="o">=</span> <span class="n">app_instance_name</span>

                        <span class="c1"># Make sure our frameworks are up and running properly for</span>
                        <span class="c1"># the new context.</span>
                        <span class="n">setup_frameworks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">)</span>

                        <span class="c1"># Repopulate the app&#39;s commands into the engine.</span>
                        <span class="k">for</span> <span class="n">command_name</span><span class="p">,</span> <span class="n">command</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__command_pool</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">app</span> <span class="ow">is</span> <span class="n">command</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;properties&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span><span class="p">[</span><span class="n">command_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">command</span>

                        <span class="c1"># Run the post method in case there&#39;s custom logic implemented</span>
                        <span class="c1"># for the app.</span>
                        <span class="n">app</span><span class="o">.</span><span class="n">post_context_change</span><span class="p">(</span><span class="n">old_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="c1"># If any of the reinitialization failed we will warn and</span>
                        <span class="c1"># continue on to a restart of the app via the normal means.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_warning</span><span class="p">(</span>
                            <span class="s2">&quot;App </span><span class="si">%r</span><span class="s2"> failed to change context and will be restarted: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                <span class="n">app</span><span class="p">,</span>
                                <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># If the reinitialization of the reused app succeeded, we</span>
                        <span class="c1"># just have to add it to the apps list and continue on to</span>
                        <span class="c1"># the next app.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;App </span><span class="si">%s</span><span class="s2"> successfully reinitialized for new context </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="n">app_instance_name</span><span class="p">,</span>
                            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
                        <span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__applications</span><span class="p">[</span><span class="n">app_instance_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">app</span>
                        <span class="k">continue</span>

            <span class="c1"># load the app</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># now get the app location and resolve it into a version object</span>
                <span class="n">app_dir</span> <span class="o">=</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>

                <span class="c1"># create the object, run the constructor</span>
                <span class="n">app</span> <span class="o">=</span> <span class="n">application</span><span class="o">.</span><span class="n">get_application</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                                                  <span class="n">app_dir</span><span class="p">,</span> 
                                                  <span class="n">descriptor</span><span class="p">,</span> 
                                                  <span class="n">app_settings</span><span class="p">,</span> 
                                                  <span class="n">app_instance_name</span><span class="p">,</span> 
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="p">)</span>
                
                <span class="c1"># load any frameworks required</span>
                <span class="n">setup_frameworks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__env</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">)</span>
                
                <span class="c1"># track the init of the app</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span> <span class="o">=</span> <span class="n">app</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">app</span><span class="o">.</span><span class="n">init_app</span><span class="p">()</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__currently_initializing_app</span> <span class="o">=</span> <span class="bp">None</span>
            
            <span class="k">except</span> <span class="n">TankError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;App </span><span class="si">%s</span><span class="s2"> failed to initialize. It will not be loaded: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">app_dir</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_exception</span><span class="p">(</span><span class="s2">&quot;App </span><span class="si">%s</span><span class="s2"> failed to initialize. It will not be loaded.&quot;</span> <span class="o">%</span> <span class="n">app_dir</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># note! Apps are keyed by their instance name, meaning that we </span>
                <span class="c1"># could theoretically have multiple instances of the same app.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__applications</span><span class="p">[</span><span class="n">app_instance_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">app</span>

            <span class="c1"># For the sake of potetial context changes, apps and commands are cached</span>
            <span class="c1"># into a persistent pool such that they can be reused at some later time.</span>
            <span class="c1"># This is required because, during context changes, some apps that were</span>
            <span class="c1"># active in the old context might not be active in the new context. Because</span>
            <span class="c1"># we might then switch BACK to the old context at some later time, or some</span>
            <span class="c1"># future context might simply make use of some of the same apps, we want</span>
            <span class="c1"># to keep a running cache of everything that&#39;s been initialized over time.</span>
            <span class="c1"># This will allow us to reuse those (assuming they support on-the-fly</span>
            <span class="c1"># context changes) rather than having to import and instantiate the same</span>
            <span class="c1"># app(s) all over again, thereby hurting performance.</span>

            <span class="c1"># Likewise, with commands, those from the old context that are not associated</span>
            <span class="c1"># with apps that are active in the new context are filtered out of the engine&#39;s</span>
            <span class="c1"># list of commands. When switching back to the old context, or any time the</span>
            <span class="c1"># associated app is reused, we can then add back in the commands that the app</span>
            <span class="c1"># had previously registered. With that, we&#39;re not required to re-run the init</span>
            <span class="c1"># process for the app.</span>

            <span class="c1"># Update the persistent application pool for use in context changes.</span>
            <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__applications</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="c1"># We will only track apps that we know can handle a context</span>
                <span class="c1"># change. Any that do not will not be treated as a persistent</span>
                <span class="c1"># app.</span>
                <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">context_change_allowed</span><span class="p">:</span>
                    <span class="n">app_path</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">descriptor</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">app_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__application_pool</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__application_pool</span><span class="p">[</span><span class="n">app_path</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">__application_pool</span><span class="p">[</span><span class="n">app</span><span class="o">.</span><span class="n">descriptor</span><span class="o">.</span><span class="n">get_path</span><span class="p">()][</span><span class="n">app_instance_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">app</span>

            <span class="c1"># Update the persistent commands pool for use in context changes.</span>
            <span class="k">for</span> <span class="n">command_name</span><span class="p">,</span> <span class="n">command</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__commands</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__command_pool</span><span class="p">[</span><span class="n">command_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">command</span>
            
    <span class="k">def</span> <span class="nf">__destroy_frameworks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroy frameworks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Destroy engine&#39;s frameworks</span>
        <span class="k">for</span> <span class="n">fw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frameworks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fw</span><span class="o">.</span><span class="n">is_shared</span><span class="p">:</span>
                <span class="n">fw</span><span class="o">.</span><span class="n">_destroy_framework</span><span class="p">()</span>
        
        <span class="c1"># Destroy shared frameworks</span>
        <span class="k">for</span> <span class="n">fw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shared_frameworks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">fw</span><span class="o">.</span><span class="n">_destroy_framework</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__shared_frameworks</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__destroy_apps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call the destroy_app method on all loaded apps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__applications</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">app</span><span class="o">.</span><span class="n">_destroy_frameworks</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;Destroying </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">app</span><span class="p">)</span>
            <span class="n">app</span><span class="o">.</span><span class="n">destroy_app</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__register_reload_command</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a &quot;Reload and Restart&quot; command with the engine if any</span>
<span class="sd">        running apps are registered via a dev descriptor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__applications</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">descriptor</span><span class="o">.</span><span class="n">is_dev</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_debug</span><span class="p">(</span><span class="s2">&quot;App </span><span class="si">%s</span><span class="s2"> is registered via a dev descriptor. Will add a reload &quot;</span>
                               <span class="s2">&quot;button to the actions listings.&quot;</span> <span class="o">%</span> <span class="n">app</span><span class="p">)</span>
                <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">restart</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register_command</span><span class="p">(</span>
                    <span class="s2">&quot;Reload and Restart&quot;</span><span class="p">,</span>
                    <span class="n">restart</span><span class="p">,</span>
                    <span class="p">{</span><span class="s2">&quot;short_name&quot;</span><span class="p">:</span> <span class="s2">&quot;restart&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;icon&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_platform_resource_file</span><span class="p">(</span><span class="s2">&quot;reload_256.png&quot;</span><span class="p">),</span>
                     <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;context_menu&quot;</span><span class="p">}</span>
                <span class="p">)</span>
                <span class="c1"># only need one reload button, so don&#39;t keep iterating :)</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">__get_platform_resource_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the full path to the given platform resource file.</span>
<span class="sd">        Resource files reside in the core/platform/qt folder.</span>

<span class="sd">        :return: full path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">this_folder</span><span class="p">,</span> <span class="s2">&quot;qt&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__run_post_engine_inits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the post_engine_init method for all running apps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__applications</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">app</span><span class="o">.</span><span class="n">post_engine_init</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">TankError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;App </span><span class="si">%s</span><span class="s2"> Failed to run its post_engine_init. It is loaded, but&quot;</span>
                               <span class="s2">&quot;may not operate in its desired state! Details: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_exception</span><span class="p">(</span><span class="s2">&quot;App </span><span class="si">%s</span><span class="s2"> failed run its post_engine_init. It is loaded, but&quot;</span>
                                   <span class="s2">&quot;may not operate in its desired state!&quot;</span> <span class="o">%</span> <span class="n">app</span><span class="p">)</span></div>


<span class="c1">##########################################################################################</span>
<span class="c1"># Engine management</span>

<span class="n">g_current_engine</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">set_current_engine</span><span class="p">(</span><span class="n">eng</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets the current engine</span>

<span class="sd">    :param eng: :class:`Engine` instance to set as current.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">g_current_engine</span>
    <span class="n">g_current_engine</span> <span class="o">=</span> <span class="n">eng</span>

<div class="viewcode-block" id="current_engine"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.current_engine">[docs]</a><span class="k">def</span> <span class="nf">current_engine</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the currently active engine.</span>

<span class="sd">    :returns: :class:`Engine` instance or None if no engine is running.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">g_current_engine</span>
    <span class="k">return</span> <span class="n">g_current_engine</span></div>


<div class="viewcode-block" id="get_engine_path"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.get_engine_path">[docs]</a><span class="k">def</span> <span class="nf">get_engine_path</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the path to the engine corresponding to the given engine name or</span>
<span class="sd">    None if the engine could not be found.</span>

<span class="sd">    Similar to :meth:`start_engine`, but instead of starting an engine, this method</span>
<span class="sd">    returns the path to a suitable engine. This helper method is sometimes useful</span>
<span class="sd">    when initializing engines for applications that do not have a built in python interpreter.</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; import sgtk</span>
<span class="sd">        &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio/project_root&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ctx = tk.context_empty()</span>
<span class="sd">        &gt;&gt;&gt; sgtk.platform.get_engine_path(&#39;tk-maya&#39;, tk, ctx)</span>
<span class="sd">        /studio/sgtk/install/engines/app_store/tk-maya/v0.1.0</span>


<span class="sd">    :param engine_name: Name of the engine to launch, e.g. tk-maya</span>
<span class="sd">    :param tk: :class:`~sgtk.Sgtk` instance to associate the engine with</span>
<span class="sd">    :param context: :class:`~sgtk.Context` object of the context to launch the engine for.</span>
<span class="sd">    :returns: Path to where the engine code is located on disk.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get environment and engine location</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">engine_descriptor</span><span class="p">)</span> <span class="o">=</span> <span class="n">_get_env_and_descriptor_for_engine</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">TankEngineInitError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># return path to engine code</span>
    <span class="n">engine_path</span> <span class="o">=</span> <span class="n">engine_descriptor</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">engine_path</span></div>


<div class="viewcode-block" id="start_engine"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.start_engine">[docs]</a><span class="k">def</span> <span class="nf">start_engine</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates an engine and makes it the current engine.</span>
<span class="sd">    Returns the newly created engine object. Example::</span>

<span class="sd">        &gt;&gt;&gt; import sgtk</span>
<span class="sd">        &gt;&gt;&gt; tk = sgtk.sgtk_from_path(&quot;/studio/project_root&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ctx = tk.context_empty()</span>
<span class="sd">        &gt;&gt;&gt; engine = sgtk.platform.start_engine(&#39;tk-maya&#39;, tk, ctx)</span>
<span class="sd">        &gt;&gt;&gt; engine</span>
<span class="sd">        &lt;Sgtk Engine 0x10451b690: tk-maya, env: shotgun&gt;</span>

<span class="sd">    :param engine_name: Name of the engine to launch, e.g. tk-maya</span>
<span class="sd">    :param tk: :class:`~sgtk.Sgtk` instance to associate the engine with</span>
<span class="sd">    :param context: :class:`~sgtk.Context` object of the context to launch the engine for.</span>
<span class="sd">    :returns: :class:`Engine` instance</span>
<span class="sd">    :raises: :class:`TankEngineInitError` if an engine could not be started</span>
<span class="sd">             for the passed context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_start_engine</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_restart_engine</span><span class="p">(</span><span class="n">new_context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Restarts an engine by destroying the previous one and creating a new one.</span>

<span class="sd">    :param new_context: Context for the new engine. If None, previous context will</span>
<span class="sd">        be reused.</span>
<span class="sd">    :type new_context: :class:`~sgtk.Context`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">engine</span> <span class="o">=</span> <span class="n">current_engine</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Track some of the current state before restarting the engine.</span>
        <span class="n">old_context</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">context</span>
        <span class="n">new_context</span> <span class="o">=</span> <span class="n">new_context</span> <span class="ow">or</span> <span class="n">engine</span><span class="o">.</span><span class="n">context</span>

        <span class="c1"># Restart the engine. If we were given a new context to use,</span>
        <span class="c1"># use it, otherwise restart using the same context as before.</span>
        <span class="n">current_engine_name</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">instance_name</span>
        <span class="k">with</span> <span class="n">_CoreContextChangeHookGuard</span><span class="p">(</span><span class="n">engine</span><span class="o">.</span><span class="n">sgtk</span><span class="p">,</span> <span class="n">old_context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">):</span>
            <span class="n">engine</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>

            <span class="n">_start_engine</span><span class="p">(</span><span class="n">current_engine_name</span><span class="p">,</span> <span class="n">new_context</span><span class="o">.</span><span class="n">tank</span><span class="p">,</span> <span class="n">old_context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">TankError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">engine</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;Could not restart the engine: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">engine</span><span class="o">.</span><span class="n">log_exception</span><span class="p">(</span><span class="s2">&quot;Could not restart the engine!&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_CoreContextChangeHookGuard</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used with the ``with`` statement, this guard will notify the context_change</span>
<span class="sd">    core hook with the pre_context_change event on entering and</span>
<span class="sd">    post_context_change even on exit if and only if the scope exits without</span>
<span class="sd">    an exception being raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_depth</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">old_context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>

<span class="sd">        :param tk: Toolkit instance.</span>
<span class="sd">        :param old_context: Current context.</span>
<span class="sd">        :param new_context: Context we&#39;re switching to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tk</span> <span class="o">=</span> <span class="n">tk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_old_context</span> <span class="o">=</span> <span class="n">old_context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_context</span> <span class="o">=</span> <span class="n">new_context</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the pre context change hook if we&#39;re the first guard instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">_depth</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># If we&#39;re the first instance of the guard, notify.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_depth</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_execute_pre_context_change</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_context</span><span class="p">)</span>

    <span class="c1"># Made static so we can introspec the content of the guard during unit testing.</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_execute_pre_context_change</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">old_context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the pre context change hook.</span>

<span class="sd">        :param tk: Toolkit instance.</span>
<span class="sd">        :param old_context: Current context.</span>
<span class="sd">        :param new_context: Context we&#39;re switching to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook_method</span><span class="p">(</span>
            <span class="n">constants</span><span class="o">.</span><span class="n">CONTEXT_CHANGE_HOOK</span><span class="p">,</span>
            <span class="s2">&quot;pre_context_change&quot;</span><span class="p">,</span>
            <span class="n">current_context</span><span class="o">=</span><span class="n">old_context</span><span class="p">,</span>
            <span class="n">next_context</span><span class="o">=</span><span class="n">new_context</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ex_type</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the post context change hook if we&#39;re the last guard instance.</span>

<span class="sd">        :param ex_type: Type of the exception raised, if any.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we are the last instance of the guard and there&#39;s no exception, notify</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">_depth</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ex_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_execute_post_context_change</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_context</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">_depth</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># Made static so we can introspec the content of the guard during unit testing.</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_execute_post_context_change</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">old_context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the post context change hook.</span>

<span class="sd">        :param tk: Toolkit instance.</span>
<span class="sd">        :param old_context: Current context.</span>
<span class="sd">        :param new_context: Context we&#39;re switching to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook_method</span><span class="p">(</span>
            <span class="n">constants</span><span class="o">.</span><span class="n">CONTEXT_CHANGE_HOOK</span><span class="p">,</span>
            <span class="s2">&quot;post_context_change&quot;</span><span class="p">,</span>
            <span class="n">previous_context</span><span class="o">=</span><span class="n">old_context</span><span class="p">,</span>
            <span class="n">current_context</span><span class="o">=</span><span class="n">new_context</span>
        <span class="p">)</span>

<span class="k">def</span> <span class="nf">_start_engine</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">old_context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Starts an engine for a given Toolkit instance and context.</span>

<span class="sd">    :param engine_name: Name of the engine to start.</span>
<span class="sd">    :param tk: Toolkit instance.</span>
<span class="sd">    :type tk: :class:`~sgtk.Sgtk`</span>
<span class="sd">    :param old_context: Context before the context change.</span>
<span class="sd">    :type old_context: :class:`~sgtk.Context`</span>
<span class="sd">    :param new_context: Context after the context change.</span>
<span class="sd">    :type new_context: :class:`~sgtk.Context`</span>

<span class="sd">    :returns: A new sgtk.platform.Engine object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># first ensure that an engine is not currently running</span>
        <span class="k">if</span> <span class="n">current_engine</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;An engine (</span><span class="si">%s</span><span class="s2">) is already running! Before you can start a new engine, &quot;</span>
                            <span class="s2">&quot;please shut down the previous one using the command &quot;</span>
                            <span class="s2">&quot;tank.platform.current_engine().destroy().&quot;</span> <span class="o">%</span> <span class="n">current_engine</span><span class="p">())</span>

        <span class="c1"># begin writing log to disk, associated with the engine</span>
        <span class="c1"># only do this if a logger hasn&#39;t been previously set up.</span>
        <span class="k">if</span> <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">base_file_handler</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">initialize_base_file_handler</span><span class="p">(</span><span class="n">engine_name</span><span class="p">)</span>

        <span class="c1"># get environment and engine location</span>
        <span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">engine_descriptor</span><span class="p">)</span> <span class="o">=</span> <span class="n">_get_env_and_descriptor_for_engine</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">new_context</span><span class="p">)</span>

        <span class="c1"># make sure it exists locally</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">engine_descriptor</span><span class="o">.</span><span class="n">exists_local</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">TankEngineInitError</span><span class="p">(</span><span class="s2">&quot;Cannot start engine! </span><span class="si">%s</span><span class="s2"> does not exist on disk&quot;</span> <span class="o">%</span> <span class="n">engine_descriptor</span><span class="p">)</span>

        <span class="c1"># get path to engine code</span>
        <span class="n">engine_path</span> <span class="o">=</span> <span class="n">engine_descriptor</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
        <span class="n">plugin_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">engine_path</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">ENGINE_FILE</span><span class="p">)</span>
        <span class="n">class_obj</span> <span class="o">=</span> <span class="n">load_plugin</span><span class="p">(</span><span class="n">plugin_file</span><span class="p">,</span> <span class="n">Engine</span><span class="p">)</span>

        <span class="c1"># Notify the context change and start the engine.</span>
        <span class="k">with</span> <span class="n">_CoreContextChangeHookGuard</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">old_context</span><span class="p">,</span> <span class="n">new_context</span><span class="p">):</span>
            <span class="c1"># Instantiate the engine</span>
            <span class="n">engine</span> <span class="o">=</span> <span class="n">class_obj</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">new_context</span><span class="p">,</span> <span class="n">engine_name</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
            <span class="c1"># register this engine as the current engine</span>
            <span class="n">set_current_engine</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="c1"># trap and log the exception and let it bubble in</span>
        <span class="c1"># unchanged form</span>
        <span class="n">core_logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Exception raised in start_engine.&quot;</span><span class="p">)</span>
        <span class="k">raise</span>

    <span class="k">return</span> <span class="n">engine</span>


<div class="viewcode-block" id="find_app_settings"><a class="viewcode-back" href="../../../platform.html#sgtk.platform.find_app_settings">[docs]</a><span class="k">def</span> <span class="nf">find_app_settings</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">app_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">engine_instance_name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility method to find the settings for an app in an engine in the</span>
<span class="sd">    environment determined for the context by pick environment hook.</span>
<span class="sd">    </span>
<span class="sd">    :param engine_name: system name of the engine to look for, e.g tk-maya</span>
<span class="sd">    :param app_name: system name of the app to look for, e.g. tk-multi-publish</span>
<span class="sd">    :param tk: :class:`~sgtk.Sgtk` instance</span>
<span class="sd">    :param context: :class:`~sgtk.Context` object to use when picking environment</span>
<span class="sd">    :param engine_instance_name: The instance name of the engine to look for.</span>
<span class="sd">    </span>
<span class="sd">    :returns: list of dictionaries containing the engine name, </span>
<span class="sd">              application name and settings for any matching</span>
<span class="sd">              applications that are found and that have valid</span>
<span class="sd">              settings</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">app_settings</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># get the environment via the pick_environment hook</span>
    <span class="n">env_name</span> <span class="o">=</span> <span class="n">__pick_environment</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_environment</span><span class="p">(</span><span class="n">env_name</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    
    <span class="c1"># now find all engines whose names match the engine_name:</span>
    <span class="k">for</span> <span class="n">eng</span> <span class="ow">in</span> <span class="n">env</span><span class="o">.</span><span class="n">get_engines</span><span class="p">():</span>
        <span class="n">eng_desc</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_engine_descriptor</span><span class="p">(</span><span class="n">eng</span><span class="p">)</span>
        <span class="n">eng_sys_name</span> <span class="o">=</span> <span class="n">eng_desc</span><span class="o">.</span><span class="n">system_name</span>

        <span class="c1"># Make sure that we get the right engine by comparing engine</span>
        <span class="c1"># name and instance name, if provided.</span>
        <span class="k">if</span> <span class="n">eng_sys_name</span> <span class="o">!=</span> <span class="n">engine_name</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">engine_instance_name</span> <span class="ow">and</span> <span class="n">engine_instance_name</span> <span class="o">!=</span> <span class="n">eng</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># ok, found engine so look for app:</span>
        <span class="k">for</span> <span class="n">app</span> <span class="ow">in</span> <span class="n">env</span><span class="o">.</span><span class="n">get_apps</span><span class="p">(</span><span class="n">eng</span><span class="p">):</span>
            <span class="n">app_desc</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_app_descriptor</span><span class="p">(</span><span class="n">eng</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">app_desc</span><span class="o">.</span><span class="n">system_name</span> <span class="o">!=</span> <span class="n">app_name</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1"># ok, found an app - lets validate the settings as</span>
            <span class="c1"># we want to ignore them if they&#39;re not valid</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">schema</span> <span class="o">=</span> <span class="n">app_desc</span><span class="o">.</span><span class="n">configuration_schema</span>
                <span class="n">settings</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_app_settings</span><span class="p">(</span><span class="n">eng</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
                
                <span class="c1"># check that the context contains all the info that the app needs</span>
                <span class="n">validation</span><span class="o">.</span><span class="n">validate_context</span><span class="p">(</span><span class="n">app_desc</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
                
                <span class="c1"># make sure the current operating system platform is supported</span>
                <span class="n">validation</span><span class="o">.</span><span class="n">validate_platform</span><span class="p">(</span><span class="n">app_desc</span><span class="p">)</span>
                                
                <span class="c1"># for multi engine apps, make sure our engine is supported</span>
                <span class="n">supported_engines</span> <span class="o">=</span> <span class="n">app_desc</span><span class="o">.</span><span class="n">supported_engines</span>
                <span class="k">if</span> <span class="n">supported_engines</span> <span class="ow">and</span> <span class="n">engine_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_engines</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;The app could not be loaded since it only supports &quot;</span>
                                    <span class="s2">&quot;the following engines: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">supported_engines</span><span class="p">)</span>
                
                <span class="c1"># finally validate the configuration.  </span>
                <span class="c1"># Note: context is set to None as we don&#39;t </span>
                <span class="c1"># want to fail validation because of an </span>
                <span class="c1"># incomplete context at this stage!</span>
                <span class="n">validation</span><span class="o">.</span><span class="n">validate_settings</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">TankError</span><span class="p">:</span>
                <span class="c1"># ignore any Tank exceptions to skip invalid apps</span>
                <span class="k">continue</span>

            <span class="c1"># settings are valid so add them to return list:</span>
            <span class="n">app_settings</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;engine_instance&quot;</span><span class="p">:</span> <span class="n">eng</span><span class="p">,</span> <span class="s2">&quot;app_instance&quot;</span><span class="p">:</span> <span class="n">app</span><span class="p">,</span> <span class="s2">&quot;settings&quot;</span><span class="p">:</span> <span class="n">settings</span><span class="p">})</span>
                    
    <span class="k">return</span> <span class="n">app_settings</span></div>
    

<span class="k">def</span> <span class="nf">start_shotgun_engine</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Special, internal method that handles the shotgun engine.</span>

<span class="sd">    :param tk:          tank instance</span>
<span class="sd">    :param entity_type: type of the entity to use as a target for picking our</span>
<span class="sd">                        shotgun environment</span>
<span class="sd">    :param context:     context to use for the shotgun engine and its apps.</span>

<span class="sd">                        If some apps require a specific context to extract</span>
<span class="sd">                        information (e.g. they call a pick_environment hook to</span>
<span class="sd">                        get the environment to use based on the context), this</span>
<span class="sd">                        should be set to something other than the empty</span>
<span class="sd">                        context.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># begin writing log to disk, associated with the engine</span>
    <span class="k">if</span> <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">base_file_handler</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">LogManager</span><span class="p">()</span><span class="o">.</span><span class="n">initialize_base_file_handler</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">SHOTGUN_ENGINE_NAME</span><span class="p">)</span>

    <span class="c1"># bypass the get_environment hook and use a fixed set of environments</span>
    <span class="c1"># for this shotgun engine. This is required because of the action caching.</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_environment</span><span class="p">(</span><span class="s2">&quot;shotgun_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">entity_type</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">context</span><span class="p">)</span>

    <span class="c1"># get the location for our engine</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">constants</span><span class="o">.</span><span class="n">SHOTGUN_ENGINE_NAME</span> <span class="ow">in</span> <span class="n">env</span><span class="o">.</span><span class="n">get_engines</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">TankEngineInitError</span><span class="p">(</span><span class="s2">&quot;Cannot find a shotgun engine in </span><span class="si">%s</span><span class="s2">. Please contact support.&quot;</span> <span class="o">%</span> <span class="n">env</span><span class="p">)</span>
    
    <span class="n">engine_descriptor</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_engine_descriptor</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">SHOTGUN_ENGINE_NAME</span><span class="p">)</span>

    <span class="c1"># make sure it exists locally</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">engine_descriptor</span><span class="o">.</span><span class="n">exists_local</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">TankEngineInitError</span><span class="p">(</span><span class="s2">&quot;Cannot start engine! </span><span class="si">%s</span><span class="s2"> does not exist on disk&quot;</span> <span class="o">%</span> <span class="n">engine_descriptor</span><span class="p">)</span>

    <span class="c1"># get path to engine code</span>
    <span class="n">engine_path</span> <span class="o">=</span> <span class="n">engine_descriptor</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
    <span class="n">plugin_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">engine_path</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">ENGINE_FILE</span><span class="p">)</span>

    <span class="c1"># Instantiate the engine</span>
    <span class="n">class_obj</span> <span class="o">=</span> <span class="n">load_plugin</span><span class="p">(</span><span class="n">plugin_file</span><span class="p">,</span> <span class="n">Engine</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">class_obj</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">SHOTGUN_ENGINE_NAME</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

    <span class="c1"># register this engine as the current engine</span>
    <span class="n">set_current_engine</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">obj</span>

<span class="k">def</span> <span class="nf">get_environment_from_context</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an environment object given a context. </span>
<span class="sd">    Returns None if no environment was found. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">env_name</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">PICK_ENVIRONMENT_CORE_HOOK_NAME</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankError</span><span class="p">(</span><span class="s2">&quot;Could not resolve an environment for context &#39;</span><span class="si">%s</span><span class="s2">&#39;. The pick &quot;</span>
                        <span class="s2">&quot;environment hook reported the following error: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">env_name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    
    <span class="k">return</span> <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_environment</span><span class="p">(</span><span class="n">env_name</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">show_global_busy</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">details</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience method.</span>
<span class="sd">    </span>
<span class="sd">    Displays or updates a global busy/progress indicator window tied to the currently running engine.</span>
<span class="sd">    For more details and documentation, see the engine class documentation of this method.</span>

<span class="sd">    :params title: Short descriptive title of what is happening</span>
<span class="sd">    :params details: Detailed message describing what is going on.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">engine</span> <span class="o">=</span> <span class="n">current_engine</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">engine</span><span class="p">:</span>
        <span class="n">engine</span><span class="o">.</span><span class="n">show_busy</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">details</span><span class="p">)</span>        
    
<span class="k">def</span> <span class="nf">clear_global_busy</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience method.</span>
<span class="sd">    </span>
<span class="sd">    Closes any open global progress indicator window tied to the currently running engine.</span>
<span class="sd">    For more details and documentation, see engine class documentation of this method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">engine</span> <span class="o">=</span> <span class="n">current_engine</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">engine</span><span class="p">:</span>
        <span class="n">engine</span><span class="o">.</span><span class="n">clear_busy</span><span class="p">()</span>

<span class="c1">##########################################################################################</span>
<span class="c1"># utilities</span>

<span class="k">def</span> <span class="nf">_get_env_and_descriptor_for_engine</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility method to return commonly needed objects when instantiating engines.</span>

<span class="sd">    :param engine_name: system name of the engine to look for, e.g tk-maya</span>
<span class="sd">    :param tk: :class:`~sgtk.Sgtk` instance</span>
<span class="sd">    :param context: :class:`~sgtk.Context` object to use when picking environment</span>
<span class="sd">    :returns: tuple with associated environment and engine descriptor)</span>
<span class="sd">    :raises: :class:`TankEngineInitError` if the engine name cannot be found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the environment via the pick_environment hook</span>
    <span class="n">env_name</span> <span class="o">=</span> <span class="n">__pick_environment</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="c1"># get the env object based on the name in the pick env hook</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">pipeline_configuration</span><span class="o">.</span><span class="n">get_environment</span><span class="p">(</span><span class="n">env_name</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="c1"># make sure that the environment has an engine instance with that name</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">engine_name</span> <span class="ow">in</span> <span class="n">env</span><span class="o">.</span><span class="n">get_engines</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">TankEngineInitError</span><span class="p">(</span><span class="s2">&quot;Cannot find an engine instance </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>

    <span class="c1"># get the location for our engine</span>
    <span class="n">engine_descriptor</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_engine_descriptor</span><span class="p">(</span><span class="n">engine_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">engine_descriptor</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__pick_environment</span><span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">tk</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call out to the pick_environment core hook to determine which environment we should load</span>
<span class="sd">    based on the current context. The Shotgun engine provides its own implementation.</span>

<span class="sd">    :param engine_name: system name of the engine to look for, e.g tk-maya</span>
<span class="sd">    :param tk: :class:`~sgtk.Sgtk` instance</span>
<span class="sd">    :param context: :class:`~sgtk.Context` object to use when picking environment</span>
<span class="sd">    :returns: name of environment.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">env_name</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">execute_core_hook</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">PICK_ENVIRONMENT_CORE_HOOK_NAME</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TankEngineInitError</span><span class="p">(</span><span class="s2">&quot;Engine </span><span class="si">%s</span><span class="s2"> cannot initialize - the pick environment hook &quot;</span>
                                 <span class="s2">&quot;reported the following error: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">env_name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># the pick_environment hook could not determine an environment</span>
        <span class="c1"># this may be because an incomplete Context was passed.</span>
        <span class="c1"># without an environment, engine creation cannot succeed.</span>
        <span class="c1"># raise an exception with a message</span>
        <span class="k">raise</span> <span class="n">TankEngineInitError</span><span class="p">(</span><span class="s2">&quot;Engine </span><span class="si">%s</span><span class="s2"> cannot initialize - the pick environment hook was not &quot;</span>
                                  <span class="s2">&quot;able to return an environment to use, given the context </span><span class="si">%s</span><span class="s2">. &quot;</span>
                                  <span class="s2">&quot;Usually this is because the context contains insufficient information &quot;</span>
                                  <span class="s2">&quot;for an environment to be determined.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">engine_name</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">env_name</span>

</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Autodesk.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'v0.18.7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2114792-1', 'auto');
  ga('send', 'pageview');
</script>



</body>
</html>